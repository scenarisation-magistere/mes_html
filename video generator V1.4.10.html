<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIDEO Generator - Générateur de vidéos interactives</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Variables et styles de base */
        :root {
            /* Couleurs principales du gradient */
            --gradient-start: #f08b65;
            --gradient-end: #cf4520;
            
            /* Couleur d'accent et ombres */
            --accent-color: #d14b2c;
            --shadow-dark: rgba(110, 20, 0, 0.3);
            --shadow-light: rgba(255, 255, 255, 0.3);
            
            /* Couleurs des onglets */
            --tab1-color: #d14b2c;
            --tab2-color: #dc5e42;
            --tab3-color: #e57158;
            --tab4-color: #ee846e;
            --tab5-color: #f79785;
            
            /* Couleurs des boutons */
            --btn-primary: #d14b2c;
            --btn-secondary: #9e9e9e;
            --btn-special: #cf4520;
            --btn-danger: #f44336;
            
            /* Autres variables */
            --text-color: #333333;
            --base-color: #f5f5f5;
            --transition: all 0.3s ease;
        }

        /* Styles globaux */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--gradient-start), var(--gradient-end));
            background-attachment: fixed;
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Header */
        .header-container {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 20px;
            background-color: white;
            box-shadow: 8px 8px 16px var(--shadow-dark);
        }

        h1 {
            text-align: center;
            color: var(--accent-color);
            margin: 0;
            padding: 0 60px;
        }

        .version-bubble {
            background-color: #7795f8;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        .signature {
            background-color: var(--tab1-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        .description {
            text-align: center;
            margin-bottom: 30px;
            font-weight: bold;
            color: white;
            padding: 15px;
            border-radius: 20px;
            box-shadow: inset 3px 3px 7px rgba(0,0,0,0.2), inset -3px -3px 7px rgba(255,255,255,0.1);
        }

        /* Structure des onglets */
        .tabs-container {
            display: flex;
            margin-bottom: 20px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 8px 8px 16px var(--shadow-dark);
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            font-weight: bold;
            box-shadow: inset 0 0 0 rgba(0,0,0,0.1), inset 0 0 0 rgba(255,255,255,0.1);
            color: white;
        }

        .tab.active {
            box-shadow: inset 3px 3px 5px rgba(0,0,0,0.2), inset -1px -1px 3px rgba(255,255,255,0.1);
            background-color: white;
            color: var(--accent-color);
        }

        .tab-1 { background-color: var(--tab1-color); }
        .tab-2 { background-color: var(--tab2-color); }
        .tab-3 { background-color: var(--tab3-color); }
        .tab-4 { background-color: var(--tab4-color); }

        .tab-content {
            padding: 20px;
            border-radius: 20px;
            box-shadow: 8px 8px 16px var(--shadow-dark);
            margin-bottom: 20px;
            display: none;
            background-color: white;
        }

        .tab-content.active {
            display: block;
        }

        /* Boutons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
            margin-right: 10px;
            margin-bottom: 10px;
            background-color: var(--base-color);
            box-shadow: 5px 5px 10px var(--shadow-dark), -2px -2px 5px var(--shadow-light);
            color: var(--text-color);
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 6px 6px 12px var(--shadow-dark), -2px -2px 5px var(--shadow-light);
        }

        .btn:active {
            box-shadow: inset 3px 3px 5px rgba(0,0,0,0.2), inset -1px -1px 3px rgba(255,255,255,0.1);
            transform: translateY(0);
        }

        .btn-primary {
            background-color: var(--btn-primary);
            color: white;
        }

        .btn-secondary {
            background-color: var(--btn-secondary);
            color: white;
        }

        .btn-special {
            background-color: var(--btn-special);
            color: white;
        }

        .btn-danger {
            background-color: var(--btn-danger);
            color: white;
        }

        .buttons {
            display: flex;
            flex-wrap: wrap;
            margin: 15px 0;
            gap: 10px;
        }

        /* Étapes et paramètres */
        .step-title {
            font-size: 1.5rem;
            color: var(--accent-color);
            margin-bottom: 15px;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 16px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.05);
        }

        .form-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 16px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
            padding-right: 40px;
        }

        .form-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 16px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.05);
            min-height: 100px;
            resize: vertical;
        }

        /* Notification style */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 16px;
            border-radius: 4px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .notification.show {
            display: block;
            opacity: 1;
        }

        /* Section blocks */
        .section-block {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .section-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--accent-color);
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }

        /* Switch toggle */
        .switch-container {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .switch-label {
            margin-right: 10px;
            font-weight: bold;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--accent-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Checkbox styles */
        .checkbox-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px 15px;
            background-color: #f5f5f5;
            border-radius: 10px;
            transition: all 0.2s;
        }

        .checkbox-item:hover {
            background-color: #e9ecef;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        /* Preview du prompt */
        .preview-container {
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 20px;
            margin-top: 20px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .preview-content {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ddd;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }

        /* Info container */
        .info-container {
            background-color: #f0f8ff;
            padding: 20px;
            border-radius: 20px;
            border-left: 5px solid var(--accent-color);
        }

        .info-container h3 {
            color: var(--accent-color);
            margin-bottom: 10px;
        }

        .info-container ol {
            margin-left: 20px;
        }

        .info-container li {
            margin-bottom: 8px;
        }

        #loading-indicator {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--accent-color);
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Template de vidéo interactive - Styles spécifiques */
        .video-template-container {
            margin-top: 20px;
        }

        /* Configuration des points d'évaluation */
        .evaluation-points-header {
            background-color: #e6eeff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            color: #4b6cb7;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .evaluation-points-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .evaluation-point-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .evaluation-point-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .evaluation-point-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--accent-color);
        }

        .evaluation-point-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .tag-type { background-color: #e6f2ff; color: #0066cc; }
        .tag-time { background-color: #fff2e6; color: #ff6600; }
        .tag-question { background-color: #f0f0f0; color: #666; }

        .point-actions {
            display: flex;
            gap: 5px;
        }

        .btn-circle {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            font-size: 14px;
        }

        .remove-point {
            background-color: #ffeeee;
            color: #ff4444;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .remove-point:hover {
            background-color: #ff4444;
            color: white;
        }

        /* Timeline styles */
        .timeline-container {
            margin: 30px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .timeline-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: #4b6cb7;
        }

        .timeline {
            position: relative;
            height: 8px;
            background-color: #ddd;
            border-radius: 4px;
            margin: 30px 0;
        }

        .timeline-point {
            position: absolute;
            top: -14px;
            width: 36px;
            height: 36px;
            background-color: white;
            border: 2px solid var(--accent-color);
            border-radius: 50%;
            transform: translateX(-50%);
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: var(--accent-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .timeline-point:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .timeline-point.active {
            background-color: var(--accent-color);
            color: white;
        }

        .timeline-point[data-type="qcm"]::after { content: "Q"; }
        .timeline-point[data-type="calcul"]::after { content: "C"; }
        .timeline-point[data-type="appariement"]::after { content: "A"; }

        .timeline-label {
            position: absolute;
            bottom: -35px;
            transform: translateX(-50%);
            font-size: 12px;
            color: #666;
            text-align: center;
            width: 60px;
        }

        .timeline-markers {
            position: relative;
            height: 20px;
            margin-top: 5px;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            font-size: 12px;
            color: #666;
        }

        /* Video preview */
        .video-preview-container {
            margin: 20px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            margin-bottom: 20px;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        .video-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .current-time {
            background-color: #f0f0f0;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-backdrop.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: white;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateY(-20px);
            transition: all 0.3s;
        }

        .modal-backdrop.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-color);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #999;
            transition: color 0.3s;
        }

        .modal-close:hover {
            color: var(--accent-color);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Styles pour les options dans le modal */
        .option-group {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .option-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .option-title {
            font-weight: bold;
            color: #555;
        }

        .option-remove {
            color: #ff4444;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            .tabs-container {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                margin-right: 0;
            }

            .header-container {
                flex-direction: column;
                text-align: center;
                padding: 20px;
            }

            h1 {
                padding: 0;
                margin: 10px 0;
            }

            .version-bubble, .signature {
                position: static;
                transform: none;
                margin: 5px 0;
            }

            .evaluation-points-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header-container">
            <div class="version-bubble">V1.4.9 BETA</div>
            <h1>VIDEO Generator - Générateur de vidéos interactives</h1>
            <div class="signature">VideoApp</div>
        </div>

        <div class="description">
            <p>Créez facilement des prompts optimisés pour générer des vidéos interactives avec des points d'évaluation personnalisés</p>
        </div>

        <div class="tabs-container">
            <div class="tab tab-1 active" data-tab="1">
                Configuration
            </div>
            <div class="tab tab-2" data-tab="2">
                Contenu
            </div>
            <div class="tab tab-3" data-tab="3">
                Apparence
            </div>
            <div class="tab tab-4" data-tab="4">
                Génération
            </div>
        </div>

        <!-- Tab 1: Configuration -->
        <div id="tab-content-1" class="tab-content active">
            <h2 class="step-title">Étape 1: Configuration de base</h2>
            
            <div class="form-group">
                <label class="form-label" for="app-title">Titre de l'application:</label>
                <input 
                    type="text" 
                    id="app-title" 
                    class="form-input" 
                    placeholder="Ex: Mathématiques - Calculs basiques" 
                    value="Vidéo Interactive"
                >
            </div>

            <div class="form-group">
                <label class="form-label" for="app-description">Description de l'application:</label>
                <textarea 
                    id="app-description" 
                    class="form-textarea" 
                    placeholder="Décrivez le but et le contenu de votre application..."
                >Une application interactive pour l'apprentissage et l'évaluation des connaissances.</textarea>
            </div>

            <div class="form-group">
                <label class="form-label" for="app-author">Auteur / Organisation:</label>
                <input 
                    type="text" 
                    id="app-author" 
                    class="form-input" 
                    placeholder="Ex: Votre nom ou organisation" 
                    value="Formateur SCORM"
                >
            </div>
            
            <div class="form-group">
                <label class="form-label" for="subject-select">Matière / Sujet:</label>
                <select 
                    id="subject-select" 
                    class="form-select"
                >
                    <option value="general" selected>Général</option>
                    <option value="math">Mathématiques</option>
                    <option value="science">Sciences</option>
                    <option value="language">Langues</option>
                    <option value="history">Histoire</option>
                    <option value="geography">Géographie</option>
                    <option value="computer">Informatique</option>
                    <option value="custom">Personnalisé</option>
                </select>
            </div>
            
            <div class="form-group" id="custom-subject-container" style="display: none;">
                <label class="form-label" for="custom-subject">Sujet personnalisé:</label>
                <input 
                    type="text" 
                    id="custom-subject" 
                    class="form-input" 
                    placeholder="Entrez votre sujet personnalisé"
                >
            </div>

            <div class="form-group">
                <label class="form-label" for="difficulty-select">Niveau de difficulté:</label>
                <select 
                    id="difficulty-select" 
                    class="form-select"
                >
                    <option value="beginner">Débutant</option>
                    <option value="intermediate" selected>Intermédiaire</option>
                    <option value="advanced">Avancé</option>
                    <option value="expert">Expert</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label" for="audience-select">Public cible:</label>
                <select 
                    id="audience-select" 
                    class="form-select"
                >
                    <option value="primary">École primaire</option>
                    <option value="secondary">Collège</option>
                    <option value="highschool">Lycée</option>
                    <option value="university">Université</option>
                    <option value="professional" selected>Formation professionnelle</option>
                    <option value="all">Tout public</option>
                </select>
            </div>

            <div class="buttons">
                <button 
                    class="btn btn-secondary" 
                    id="reset-button-1"
                >
                    <i class="fas fa-sync-alt"></i> Réinitialiser
                </button>
                <button 
                    class="btn btn-primary" 
                    id="next-tab-1"
                >
                    Suivant <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>

        <!-- Tab 2: Content -->
        <div id="tab-content-2" class="tab-content">
            <h2 class="step-title">Étape 2: Configuration du contenu</h2>
            
            <!-- Configuration vidéo -->
            <div id="video-template-config" class="section-block">
                <div class="section-title">Paramètres spécifiques au template: Vidéo Interactive</div>
                
                <div class="form-group">
                    <label class="form-label" for="video-url">URL de la vidéo YouTube:</label>
                    <input 
                        type="text" 
                        id="video-url" 
                        class="form-input" 
                        placeholder="https://youtu.be/VIDEO_ID ou https://www.youtube.com/watch?v=VIDEO_ID"
                    >
                    <p class="form-hint" style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        Collez l'URL complète ou l'ID de la vidéo YouTube.
                    </p>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Durée de la vidéo:</label>
                    <div style="display: flex; gap: 15px;">
                        <div style="flex: 1;">
                            <label class="form-label" for="video-start">Début (secondes):</label>
                            <input 
                                type="number" 
                                id="video-start" 
                                class="form-input" 
                                min="0" 
                                value="0"
                            >
                        </div>
                        <div style="flex: 1;">
                            <label class="form-label" for="video-end">Fin (secondes):</label>
                            <input 
                                type="number" 
                                id="video-end" 
                                class="form-input" 
                                min="0" 
                                value="240"
                            >
                        </div>
                    </div>
                </div>
                
                <!-- Configuration des points d'évaluation -->
                <div class="evaluation-points-header">
                    Configuration des points d'évaluation
                </div>
                
                <div class="evaluation-points-actions">
                    <button class="btn btn-primary" id="add-evaluation-point">
                        <i class="fas fa-plus"></i> Ajouter un point
                    </button>
                    <button class="btn btn-secondary" id="reorder-evaluation-points">
                        <i class="fas fa-sort"></i> Trier par temps
                    </button>
                    <button class="btn btn-special" id="distribute-evaluation-points">
                        <i class="fas fa-ruler"></i> Distribuer uniformément
                    </button>
                </div>
                
                <!-- Liste des points d'évaluation -->
                <div id="evaluation-points-list">
                    <!-- Les points d'évaluation seront ajoutés ici dynamiquement -->
                </div>
                
                <!-- Timeline des points d'évaluation -->
                <div class="timeline-container">
                    <div class="timeline-header">
                        <div class="timeline-title">Timeline des points d'évaluation</div>
                    </div>
                    
                    <div class="timeline" id="evaluation-timeline">
                        <!-- Les points seront ajoutés ici dynamiquement -->
                    </div>
                    
                    <div class="timeline-markers" id="timeline-markers">
                        <!-- Les marqueurs de temps seront ajoutés ici dynamiquement -->
                    </div>
                    
                    <p style="text-align: center; color: #666; margin-top: 10px; font-size: 0.9em;">
                        Cliquez et glissez les points pour ajuster leur position. Les points d'évaluation apparaîtront à ces moments pendant la lecture de la vidéo.
                    </p>
                </div>
                
                <!-- Prévisualisation vidéo -->
                <div class="video-preview-container">
                    <div class="section-title">Prévisualisation vidéo</div>
                    
                    <div class="video-wrapper" id="video-preview-wrapper">
                        <div id="yt-preview-player"></div>
                    </div>
                    
                    <div class="video-controls">
                        <button id="sync-point-button" class="btn btn-special">
                            <i class="fas fa-stopwatch"></i> Créer un point à la position actuelle
                        </button>
                        <div class="current-time" id="current-time-display">Position: 0:00</div>
                    </div>
                    
                    <p style="text-align: center; color: #666; margin-top: 10px; font-size: 0.9em;">
                        Utilisez cette prévisualisation pour repérer les moments où placer vos points d'évaluation. Cliquez sur "Créer un point" pendant la lecture pour ajouter un point à la position actuelle.
                    </p>
                </div>
            </div>
            
            <div class="section-block">
                <div class="section-title">Gamification</div>
                
                <div class="switch-container">
                    <span class="switch-label">Activer les badges:</span>
                    <label class="switch">
                        <input type="checkbox" id="enable-badges" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div id="badges-settings">
                    <div class="form-group">
                        <label class="form-label" for="badge-threshold">Seuil pour débloquer les badges:</label>
                        <select id="badge-threshold" class="form-select">
                            <option value="percentage">Pourcentage de complétion</option>
                            <option value="count" selected>Nombre d'exercices complétés</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="badge-count">Nombre de badges:</label>
                        <select id="badge-count" class="form-select">
                            <option value="2">2 badges</option>
                            <option value="3">3 badges</option>
                            <option value="4" selected>4 badges</option>
                            <option value="5">5 badges</option>
                            <option value="6">6 badges</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="buttons">
                <button 
                    class="btn btn-secondary" 
                    id="prev-tab-2"
                >
                    <i class="fas fa-arrow-left"></i> Précédent
                </button>
                <button 
                    class="btn btn-primary" 
                    id="next-tab-2"
                >
                    Suivant <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>

        <!-- Tab 3: Appearance -->
        <div id="tab-content-3" class="tab-content">
            <h2 class="step-title">Étape 3: Personnalisation de l'apparence</h2>
            
            <div class="section-block">
                <div class="section-title">Thème et couleurs</div>
                
                <div class="form-group">
                    <label class="form-label" for="color-theme">Thème de couleur:</label>
                    <select id="color-theme" class="form-select">
                        <option value="blue" selected>Bleu (Défaut)</option>
                        <option value="green">Vert</option>
                        <option value="purple">Violet</option>
                        <option value="orange">Orange</option>
                        <option value="red">Rouge</option>
                        <option value="dark">Sombre</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="custom-primary-color">Couleur secondaire (personnalisée):</label>
                    <input 
                        type="color" 
                        id="custom-primary-color" 
                        class="form-input" 
                        value="#667eea"
                    >
                </div>
                
                <div class="switch-container">
                    <span class="switch-label">Utiliser la couleur personnalisée:</span>
                    <label class="switch">
                        <input type="checkbox" id="use-custom-color">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="section-block">
                <div class="section-title">Style d'interface</div>
                
                <div class="form-group">
                    <label class="form-label" for="ui-style">Style d'interface:</label>
                    <select id="ui-style" class="form-select">
                        <option value="modern" selected>Moderne (cards et ombres)</option>
                        <option value="flat">Plat (minimaliste)</option>
                        <option value="gradient">Dégradés (coloré)</option>
                        <option value="classic">Classique (bordures fines)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="font-family">Police de caractères:</label>
                    <select id="font-family" class="form-select">
                        <option value="sans-serif" selected>Sans-serif (Arial, Helvetica)</option>
                        <option value="serif">Serif (Times New Roman)</option>
                        <option value="monospace">Monospace (Courier)</option>
                        <option value="rounded">Arrondie (Comic Sans MS)</option>
                    </select>
                </div>
            </div>
            
            <div class="section-block">
                <div class="section-title">Fonctionnalités d'interface</div>
                
                <div class="checkbox-container">
                    <div class="checkbox-item">
                        <input type="checkbox" id="feature-fullscreen" checked>
                        <label for="feature-fullscreen">Mode plein écran</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="feature-progress" checked>
                        <label for="feature-progress">Barre de progression</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="feature-scoreboard" checked>
                        <label for="feature-scoreboard">Tableau de score</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="feature-timer">
                        <label for="feature-timer">Chronomètre</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="feature-hints" checked>
                        <label for="feature-hints">Indices</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="feature-feedback" checked>
                        <label for="feature-feedback">Feedback détaillé</label>
                    </div>
                </div>
            </div>
            
            <div class="section-block">
                <div class="section-title">Styles CSS personnalisés (avancé)</div>
                
                <div class="form-group">
                    <label class="form-label" for="custom-css">CSS personnalisé:</label>
                    <textarea 
                        id="custom-css" 
                        class="form-textarea" 
                        placeholder="/* Ajoutez votre CSS personnalisé ici */"
                        style="font-family: monospace; min-height: 150px;"
                    ></textarea>
                </div>
            </div>

            <div class="buttons">
                <button 
                    class="btn btn-secondary" 
                    id="prev-tab-3"
                >
                    <i class="fas fa-arrow-left"></i> Précédent
                </button>
                <button 
                    class="btn btn-primary" 
                    id="next-tab-3"
                >
                    Suivant <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>

        <!-- Tab 4: Generation -->
        <div id="tab-content-4" class="tab-content">
            <h2 class="step-title">Étape 4: Génération du prompt</h2>
            
            <div class="buttons" style="margin-bottom: 20px">
                <button 
                    class="btn btn-primary" 
                    id="generate-prompt-btn"
                >
                    <i class="fas fa-wand-magic-sparkles"></i> Générer le prompt
                </button>
                <button 
                    class="btn btn-special" 
                    id="copy-prompt-btn"
                    disabled
                >
                    <i class="fas fa-copy"></i> Copier le prompt
                </button>
                <button 
                    class="btn btn-secondary" 
                    id="download-prompt-btn"
                    disabled
                >
                    <i class="fas fa-download"></i> Télécharger le prompt
                </button>
            </div>
            
            <div class="section-block">
                <div class="section-title">Options de génération</div>
                
                <div class="form-group">
                    <label class="form-label" for="prompt-format">Format du prompt:</label>
                    <select id="prompt-format" class="form-select">
                        <option value="detailed" selected>Détaillé (recommandé)</option>
                        <option value="concise">Concis</option>
                        <option value="technical">Technique (avancé)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="ai-target">Optimisé pour:</label>
                    <select id="ai-target" class="form-select">
                        <option value="claude" selected>Claude (Anthropic)</option>
                        <option value="gpt">ChatGPT (OpenAI)</option>
                        <option value="generic">IA générique</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="include-code">Inclure le code technique:</label>
                    <select id="include-code" class="form-select">
                        <option value="full" selected>Oui, code complet</option>
                        <option value="partial">Oui, code partiel</option>
                        <option value="no">Non, seulement les instructions</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="additional-instructions">Instructions supplémentaires:</label>
                    <textarea 
                        id="additional-instructions" 
                        class="form-textarea" 
                        placeholder="Instructions supplémentaires pour l'IA..."
                    ></textarea>
                </div>
            </div>
            
            <div id="loading-indicator">
                <div class="spinner"></div>
                <p>Génération du prompt en cours...</p>
            </div>
            
            <div class="form-group">
                <div class="preview-container">
                    <div class="preview-header">
                        <h3>Prompt généré</h3>
                        <div>
                            <button 
                                class="btn btn-special" 
                                id="toggle-technical-btn" 
                                title="Afficher/masquer les sections techniques"
                                disabled
                            >
                                <i class="fas fa-code"></i> Afficher code
                            </button>
                        </div>
                    </div>
                    <div class="preview-content" id="prompt-preview">
                        Cliquez sur "Générer le prompt" pour créer votre prompt personnalisé...
                    </div>
                </div>
            </div>
            
            <div class="form-group">
                <div class="info-container">
                    <h3>Comment utiliser ce prompt ?</h3>
                    <ol>
                        <li>Cliquez sur le bouton "Générer le prompt" ci-dessus</li>
                        <li>Utilisez "Copier le prompt" pour le copier dans votre presse-papiers</li>
                        <li>Ouvrez votre IA préférée (Claude, ChatGPT, etc.)</li>
                        <li>Collez le prompt et envoyez-le</li>
                        <li>L'IA générera une application SCORM complète basée sur vos spécifications</li>
                        <li>Copiez le code généré dans un fichier HTML et ouvrez-le dans votre navigateur</li>
                        <li>Vous pouvez également l'intégrer dans votre LMS compatible SCORM</li>
                    </ol>
                </div>
            </div>

            <div class="buttons">
                <button 
                    class="btn btn-secondary" 
                    id="prev-tab-4"
                >
                    <i class="fas fa-arrow-left"></i> Précédent
                </button>
                <button 
                    class="btn btn-primary" 
                    id="open-claude-btn"
                >
                    <i class="fas fa-robot"></i> Ouvrir Claude
                </button>
                <button 
                    class="btn btn-secondary" 
                    id="open-chatgpt-btn"
                >
                    <i class="fas fa-comment-dots"></i> Ouvrir ChatGPT
                </button>
            </div>
        </div>
    </div>

    <!-- Modal de configuration de point d'évaluation -->
    <div class="modal-backdrop" id="point-config-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Configuration du point d'évaluation</div>
                <button class="modal-close" id="modal-close">&times;</button>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Le contenu sera généré dynamiquement -->
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="modal-cancel">Annuler</button>
                <button class="btn btn-primary" id="modal-save">Enregistrer</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification">Opération réussie!</div>

    <script>
        // État de l'application
        const appState = {
            // Tab 1: Configuration
            title: "Vidéo Interactive",
            description: "Une application interactive pour l'apprentissage et l'évaluation des connaissances.",
            author: "Formateur SCORM",
            subject: "general",
            customSubject: "",
            difficulty: "intermediate",
            audience: "professional",
            
            // Tab 2: Template
            selectedTemplate: "video",
            
            // Tab 3: Content
            contentTheme: "",
            contentInstructions: "Regardez attentivement la vidéo. Des questions apparaîtront à différents moments pour tester votre compréhension. Répondez correctement pour obtenir un score maximum.",
            enableBadges: true,
            badgeThreshold: "count",
            badgeCount: 4,
            
            // Paramètres spécifiques au template vidéo
            templateSettings: {
                video: {
                    videoUrl: "",
                    videoId: "",
                    startTime: 0,
                    endTime: 240,
                    evaluationPoints: []
                }
            },
            
            // Tab 4: Appearance
            colorTheme: "blue",
            customPrimaryColor: "#667eea",
            useCustomColor: false,
            uiStyle: "modern",
            fontFamily: "sans-serif",
            features: {
                fullscreen: true,
                progress: true,
                scoreboard: true,
                timer: false,
                hints: true,
                feedback: true
            },
            customCSS: "",
            
            // Tab 5: Generation
            promptFormat: "detailed",
            aiTarget: "claude",
            includeCode: "full",
            additionalInstructions: "",
            showCode: false,
            generatedPrompt: ""
        };

        // Variables globales pour YouTube API
        let player;
        let youtubeApiLoaded = false;

        // Fonction pour changer d'onglet
        function changeTab(tabNumber) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(`tab-content-${tabNumber}`).classList.add('active');
            document.querySelector(`.tab-${tabNumber}`).classList.add('active');
        }

        // Fonction pour afficher une notification
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Fonction pour initialiser les points d'évaluation par défaut
        function initializeEvaluationPoints(count = 3) {
            const points = [];
            const duration = appState.templateSettings.video.endTime - appState.templateSettings.video.startTime;
            
            for (let i = 0; i < count; i++) {
                const time = Math.round(appState.templateSettings.video.startTime + (duration / (count + 1)) * (i + 1));
                
                points.push(JSON.parse(JSON.stringify({
                    id: Date.now() + i, // ID unique avec offset pour éviter les collisions
                    time: time,
                    type: "qcm", // Type par défaut
                    config: {
                        question: `Question ${i + 1}`,
                        options: ["Option A", "Option B", "Option C"],
                        correctAnswer: "option0"
                    }
                })));
            }
            
            return points;
        }

        // Fonction pour ajouter un point d'évaluation
        function addEvaluationPoint() {
            // Définir le temps par défaut (après le dernier point ou au milieu)
            let time = appState.templateSettings.video.startTime + 30; // Par défaut, 30 secondes après le début
            
            // Si des points existent déjà, placer le nouveau après le dernier
            if (appState.templateSettings.video.evaluationPoints.length > 0) {
                const lastPoint = [...appState.templateSettings.video.evaluationPoints].sort((a, b) => b.time - a.time)[0];
                time = lastPoint.time + 15; // 15 secondes après le dernier point
            }
            
            // S'assurer que le temps ne dépasse pas la fin de la vidéo
            if (time > appState.templateSettings.video.endTime) {
                time = Math.max(appState.templateSettings.video.startTime, 
                               (appState.templateSettings.video.startTime + appState.templateSettings.video.endTime) / 2);
            }
            
            const newPoint = {
                id: Date.now(), // ID unique basé sur le timestamp
                time: time,
                type: "qcm", // Type par défaut
                config: {
                    question: `Question ${appState.templateSettings.video.evaluationPoints.length + 1}`,
                    options: ["Option A", "Option B", "Option C"],
                    correctAnswer: "option0"
                }
            };
            
            // Ajouter le nouveau point comme copie profonde pour éviter les références partagées
            appState.templateSettings.video.evaluationPoints.push(JSON.parse(JSON.stringify(newPoint)));
            
            // Mettre à jour l'interface
            renderEvaluationPoints();
            renderTimelinePoints();
            
            showNotification("Point d'évaluation ajouté");
        }

        // Fonction pour supprimer un point d'évaluation
        function removeEvaluationPoint(pointId) {
            appState.templateSettings.video.evaluationPoints = 
                appState.templateSettings.video.evaluationPoints.filter(point => point.id !== pointId);
            
            // Mettre à jour l'interface
            renderEvaluationPoints();
            renderTimelinePoints();
            
            showNotification("Point d'évaluation supprimé");
        }

        // Fonction pour trier les points d'évaluation par temps
        function reorderEvaluationPoints() {
            appState.templateSettings.video.evaluationPoints.sort((a, b) => a.time - b.time);
            
            // Mettre à jour l'interface
            renderEvaluationPoints();
            renderTimelinePoints();
            
            showNotification("Points d'évaluation triés par temps");
        }

        // Fonction pour distribuer uniformément les points d'évaluation
        function distributeEvaluationPoints() {
            const points = appState.templateSettings.video.evaluationPoints;
            if (points.length <= 1) return;
            
            const startTime = appState.templateSettings.video.startTime;
            const endTime = appState.templateSettings.video.endTime;
            const duration = endTime - startTime;
            const segment = duration / (points.length + 1);
            
            // Distribuer les points uniformément
            points.forEach((point, index) => {
                point.time = Math.round(startTime + segment * (index + 1));
            });
            
            // Mettre à jour l'interface
            renderEvaluationPoints();
            renderTimelinePoints();
            
            showNotification("Points d'évaluation distribués uniformément");
        }

        // Fonction pour formater le temps (secondes -> mm:ss)
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Fonction pour afficher les points d'évaluation
        function renderEvaluationPoints() {
            const container = document.getElementById('evaluation-points-list');
            if (!container) return;
            
            container.innerHTML = '';
            
            appState.templateSettings.video.evaluationPoints.forEach((point, index) => {
                const pointElement = document.createElement('div');
                pointElement.className = 'evaluation-point-item';
                pointElement.dataset.id = point.id;
                
                const typeLabels = {
                    'qcm': 'QCM',
                    'calcul': 'Calcul',
                    'appariement': 'Appariement'
                };
                
                const typeIcon = {
                    'qcm': '<i class="fas fa-tasks"></i>',
                    'calcul': '<i class="fas fa-calculator"></i>',
                    'appariement': '<i class="fas fa-link"></i>'
                };
                
                pointElement.innerHTML = `
                    <div class="evaluation-point-header">
                        <div class="evaluation-point-title">Point d'évaluation ${index + 1}</div>
                        <div class="point-actions">
                            <button class="btn btn-primary btn-circle configure-point" data-id="${point.id}">
                                <i class="fas fa-cog"></i>
                            </button>
                        </div>
                    </div>
                    <div class="evaluation-point-tags">
                        <div class="tag tag-type">${typeIcon[point.type] || ''} Type: ${typeLabels[point.type] || 'QCM'}</div>
                        <div class="tag tag-time"><i class="fas fa-clock"></i> Temps: ${formatTime(point.time)}</div>
                        <div class="tag tag-question" title="${point.config.question}">
                            <i class="fas fa-question-circle"></i> Question: ${point.config.question.length > 30 ? point.config.question.substring(0, 30) + '...' : point.config.question}
                        </div>
                    </div>
                    <button class="remove-point" data-id="${point.id}">×</button>
                `;
                
                container.appendChild(pointElement);
            });
            
            // Ajouter les écouteurs d'événements
            document.querySelectorAll('.remove-point').forEach(btn => {
                btn.addEventListener('click', function() {
                    const pointId = parseInt(this.dataset.id);
                    removeEvaluationPoint(pointId);
                });
            });
            
            document.querySelectorAll('.configure-point').forEach(btn => {
                btn.addEventListener('click', function() {
                    const pointId = parseInt(this.dataset.id);
                    showPointConfigModal(pointId);
                });
            });
        }

        // Fonction pour afficher les points sur la timeline
        function renderTimelinePoints() {
            const timeline = document.getElementById('evaluation-timeline');
            const markers = document.getElementById('timeline-markers');
            
            if (!timeline || !markers) return;
            
            // Vider la timeline et les marqueurs
            timeline.innerHTML = '';
            markers.innerHTML = '';
            
            const startTime = appState.templateSettings.video.startTime;
            const endTime = appState.templateSettings.video.endTime;
            const duration = endTime - startTime;
            
            // Ajouter des marqueurs de temps à intervalles réguliers
            const intervalCount = 5; // Nombre d'intervalles
            for (let i = 0; i <= intervalCount; i++) {
                const time = startTime + (duration / intervalCount) * i;
                const position = (i / intervalCount) * 100;
                
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.style.left = `${position}%`;
                marker.textContent = formatTime(time);
                markers.appendChild(marker);
            }
            
            // Ajouter les points d'évaluation
            appState.templateSettings.video.evaluationPoints.forEach(point => {
                const position = ((point.time - startTime) / duration) * 100;
                
                // S'assurer que la position est dans les limites (0-100%)
                const clampedPosition = Math.max(0, Math.min(100, position));
                
                const pointElement = document.createElement('div');
                pointElement.className = 'timeline-point';
                pointElement.dataset.id = point.id;
                pointElement.dataset.time = point.time;
                pointElement.dataset.type = point.type;
                pointElement.style.left = `${clampedPosition}%`;
                
                // Ajouter le label de temps
                const label = document.createElement('div');
                label.className = 'timeline-label';
                label.textContent = formatTime(point.time);
                pointElement.appendChild(label);
                
                timeline.appendChild(pointElement);
                
                // Rendre le point déplaçable
                makePointDraggable(pointElement);
            });
        }

        // Fonction pour rendre un point déplaçable sur la timeline
        function makePointDraggable(pointElement) {
            let isDragging = false;
            let startX, startLeft;
            
            pointElement.addEventListener('mousedown', startDrag);
            pointElement.addEventListener('touchstart', startDrag, { passive: false });
            
            function startDrag(e) {
                e.preventDefault();
                isDragging = true;
                
                // Enregistrer la position initiale
                startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                startLeft = parseFloat(pointElement.style.left);
                
                // Ajouter les écouteurs pour le déplacement et la fin
                document.addEventListener('mousemove', onDrag);
                document.addEventListener('touchmove', onDrag, { passive: false });
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
                
                // Ajouter une classe pour le style
                pointElement.style.cursor = 'grabbing';
                pointElement.classList.add('active');
            }
            
            function onDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const timeline = document.getElementById('evaluation-timeline');
                const timelineRect = timeline.getBoundingClientRect();
                
                // Calculer la nouvelle position
                const currentX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const deltaX = currentX - startX;
                const newLeft = startLeft + (deltaX / timelineRect.width) * 100;
                
                // Limiter la position entre 0 et 100%
                const clampedLeft = Math.max(0, Math.min(100, newLeft));
                pointElement.style.left = `${clampedLeft}%`;
                
                // Mettre à jour le label de temps
                const startTime = appState.templateSettings.video.startTime;
                const endTime = appState.templateSettings.video.endTime;
                const duration = endTime - startTime;
                
                const newTime = Math.round(startTime + (clampedLeft / 100) * duration);
                pointElement.dataset.time = newTime;
                
                const label = pointElement.querySelector('.timeline-label');
                if (label) {
                    label.textContent = formatTime(newTime);
                }
            }
            
            function endDrag() {
                if (!isDragging) return;
                isDragging = false;
                
                // Mettre à jour le temps du point dans l'état
                const pointId = parseInt(pointElement.dataset.id);
                const newTime = parseInt(pointElement.dataset.time);
                
                const point = appState.templateSettings.video.evaluationPoints.find(p => p.id === pointId);
                if (point) {
                    point.time = newTime;
                    
                    // Mettre à jour l'affichage des points d'évaluation
                    renderEvaluationPoints();
                }
                
                // Supprimer les écouteurs
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchend', endDrag);
                
                // Restaurer le style
                pointElement.style.cursor = 'grab';
                pointElement.classList.remove('active');
            }
        }

        // Fonction pour afficher le modal de configuration de point
        function showPointConfigModal(pointId) {
            // Trouver le point spécifique par son ID
            const pointIndex = appState.templateSettings.video.evaluationPoints.findIndex(p => p.id === pointId);
            if (pointIndex === -1) return;
            
            // Référence au point à configurer
            const point = JSON.parse(JSON.stringify(appState.templateSettings.video.evaluationPoints[pointIndex]));
            
            const modalBody = document.getElementById('modal-body');
            const modal = document.getElementById('point-config-modal');
            
            // Stocker l'ID du point en cours d'édition dans le modal
            modal.dataset.currentPointId = pointId;
            
            // Générer le contenu du modal selon le type de point
            let content = `
                <div class="form-group">
                    <label class="form-label" for="modal-point-time">Temps (secondes):</label>
                    <input type="number" id="modal-point-time" class="form-input" min="0" value="${point.time}">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="modal-point-type">Type de question:</label>
                    <select id="modal-point-type" class="form-select">
                        <option value="qcm" ${point.type === 'qcm' ? 'selected' : ''}>QCM</option>
                        <option value="calcul" ${point.type === 'calcul' ? 'selected' : ''}>Calcul</option>
                        <option value="appariement" ${point.type === 'appariement' ? 'selected' : ''}>Appariement</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="modal-point-question">Question:</label>
                    <input type="text" id="modal-point-question" class="form-input" value="${point.config.question}">
                </div>
            `;
            
            // Configuration spécifique selon le type
            if (point.type === 'qcm') {
                content += `
                    <div class="form-group">
                        <label class="form-label" for="modal-option-count">Nombre d'options:</label>
                        <select id="modal-option-count" class="form-select">
                            <option value="2" ${point.config.options.length === 2 ? 'selected' : ''}>2 options</option>
                            <option value="3" ${point.config.options.length === 3 ? 'selected' : ''}>3 options</option>
                            <option value="4" ${point.config.options.length === 4 ? 'selected' : ''}>4 options</option>
                        </select>
                    </div>
                    
                    <div id="modal-options-container">
                `;
                
                // Ajouter les options
                point.config.options.forEach((option, index) => {
                    content += `
                        <div class="form-group">
                            <label class="form-label" for="modal-option-${index}">Option ${String.fromCharCode(65 + index)}:</label>
                            <input type="text" id="modal-option-${index}" class="form-input" value="${option}">
                        </div>
                    `;
                });
                
                content += `
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="modal-correct-answer">Réponse correcte:</label>
                        <select id="modal-correct-answer" class="form-select">
                `;
                
                // Ajouter les options pour la réponse correcte
                point.config.options.forEach((option, index) => {
                    content += `
                        <option value="option${index}" ${point.config.correctAnswer === `option${index}` ? 'selected' : ''}>
                            Option ${String.fromCharCode(65 + index)}
                        </option>
                    `;
                });
                
                content += `
                        </select>
                    </div>
                `;
            } else if (point.type === 'calcul') {
                // Configuration pour les questions de calcul
                content += `
                    <div class="form-group">
                        <label class="form-label" for="modal-formula">Formule:</label>
                        <input type="text" id="modal-formula" class="form-input" value="${point.config.formula || 'A = B × C'}">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="modal-correct-result">Résultat correct:</label>
                        <input type="number" id="modal-correct-result" class="form-input" step="0.01" value="${point.config.correctResult || 0}">
                    </div>
                `;
            } else if (point.type === 'appariement') {
                // Configuration pour les questions d'appariement
                content += `
                    <div class="form-group">
                        <label class="form-label" for="modal-pair-count">Nombre de paires:</label>
                        <select id="modal-pair-count" class="form-select">
                            <option value="2" ${(point.config.terms && point.config.terms.length === 2) ? 'selected' : ''}>2 paires</option>
                            <option value="3" ${(point.config.terms && point.config.terms.length === 3) ? 'selected' : ''}>3 paires</option>
                            <option value="4" ${(point.config.terms && point.config.terms.length === 4) ? 'selected' : ''}>4 paires</option>
                            <option value="5" ${(point.config.terms && point.config.terms.length === 5) ? 'selected' : ''}>5 paires</option>
                        </select>
                    </div>
                    
                    <div id="modal-pairs-container">
                `;
                
                // Initialiser les termes et définitions s'ils n'existent pas
                if (!point.config.terms) {
                    point.config.terms = ['Terme 1', 'Terme 2', 'Terme 3'];
                    point.config.definitions = ['Définition 1', 'Définition 2', 'Définition 3'];
                }
                
                // Ajouter les paires
                for (let i = 0; i < point.config.terms.length; i++) {
                    content += `
                        <div class="option-group">
                            <div class="option-header">
                                <div class="option-title">Paire ${i + 1}</div>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="modal-term-${i}">Terme:</label>
                                <input type="text" id="modal-term-${i}" class="form-input" value="${point.config.terms[i]}">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="modal-definition-${i}">Définition:</label>
                                <input type="text" id="modal-definition-${i}" class="form-input" value="${point.config.definitions[i]}">
                            </div>
                        </div>
                    `;
                }
                
                content += `
                    </div>
                `;
            }
            
            modalBody.innerHTML = content;
            
            // Afficher le modal
            modal.classList.add('active');
            
            // Ajouter les écouteurs pour le type de question
            const typeSelect = document.getElementById('modal-point-type');
            if (typeSelect) {
                typeSelect.addEventListener('change', function() {
                    // Récupérer l'ID du point en cours d'édition
                    const currentPointId = parseInt(modal.dataset.currentPointId);
                    if (isNaN(currentPointId)) return;
                    
                    // Trouver le point par son ID
                    const pointIndex = appState.templateSettings.video.evaluationPoints.findIndex(p => p.id === currentPointId);
                    if (pointIndex === -1) return;
                    
                    // Stocker les valeurs actuelles
                    const currentTime = document.getElementById('modal-point-time').value;
                    const currentQuestion = document.getElementById('modal-point-question').value;
                    
                    // Mettre à jour le point avec le nouveau type
                    const newType = this.value;
                    
                    // Créer une version temporaire du point avec le nouveau type
                    const tempPoint = {
                        id: currentPointId,
                        time: parseInt(currentTime),
                        type: newType,
                        config: {
                            question: currentQuestion
                        }
                    };
                    
                    // Initialiser la configuration selon le type
                    if (newType === 'qcm') {
                        tempPoint.config.options = ['Option A', 'Option B', 'Option C'];
                        tempPoint.config.correctAnswer = 'option0';
                    } else if (newType === 'calcul') {
                        tempPoint.config.formula = 'A = B × C';
                        tempPoint.config.correctResult = 0;
                    } else if (newType === 'appariement') {
                        tempPoint.config.terms = ['Terme 1', 'Terme 2', 'Terme 3'];
                        tempPoint.config.definitions = ['Définition 1', 'Définition 2', 'Définition 3'];
                    }
                    
                    // Mettre à jour temporairement le point dans l'état pour refléter le changement de type
                    const oldPoint = JSON.parse(JSON.stringify(appState.templateSettings.video.evaluationPoints[pointIndex]));
                    
                    // Initialiser la configuration selon le type
                    if (newType === 'qcm') {
                        tempPoint.config.options = ['Option A', 'Option B', 'Option C'];
                        tempPoint.config.correctAnswer = 'option0';
                    } else if (newType === 'calcul') {
                        tempPoint.config.formula = 'A = B × C';
                        tempPoint.config.correctResult = 0;
                    } else if (newType === 'appariement') {
                        tempPoint.config.terms = ['Terme 1', 'Terme 2', 'Terme 3'];
                        tempPoint.config.definitions = ['Définition 1', 'Définition 2', 'Définition 3'];
                    }
                    
                    // Mettre à jour le point dans l'état
                    appState.templateSettings.video.evaluationPoints[pointIndex] = JSON.parse(JSON.stringify(tempPoint));
                    
                    // Mettre à jour visuellement le point dans la timeline
                    const timelinePoint = document.querySelector(`.timeline-point[data-id="${currentPointId}"]`);
                    if (timelinePoint) {
                        timelinePoint.dataset.type = newType;
                    }
                    
                    // Stocker l'ancien point dans le modal pour restauration si annulation
                    document.getElementById('modal-close').dataset.oldPoint = JSON.stringify(oldPoint);
                    document.getElementById('modal-cancel').dataset.oldPoint = JSON.stringify(oldPoint);
                    
                    // Rafraîchir le modal avec la nouvelle configuration
                    showPointConfigModal(currentPointId);
                });
            }
            
            // Ajouter les écouteurs pour le nombre d'options (QCM)
            const optionCountSelect = document.getElementById('modal-option-count');
            if (optionCountSelect) {
                optionCountSelect.addEventListener('change', function() {
                    const optionCount = parseInt(this.value);
                    const optionsContainer = document.getElementById('modal-options-container');
                    
                    // Générer les champs d'options
                    let optionsHTML = '';
                    for (let i = 0; i < optionCount; i++) {
                        const optionValue = i < point.config.options.length ? point.config.options[i] : `Option ${String.fromCharCode(65 + i)}`;
                        optionsHTML += `
                            <div class="form-group">
                                <label class="form-label" for="modal-option-${i}">Option ${String.fromCharCode(65 + i)}:</label>
                                <input type="text" id="modal-option-${i}" class="form-input" value="${optionValue}">
                            </div>
                        `;
                    }
                    
                    optionsContainer.innerHTML = optionsHTML;
                    
                    // Mettre à jour le sélecteur de réponse correcte
                    const correctAnswerSelect = document.getElementById('modal-correct-answer');
                    correctAnswerSelect.innerHTML = '';
                    
                    for (let i = 0; i < optionCount; i++) {
                        const option = document.createElement('option');
                        option.value = `option${i}`;
                        option.textContent = `Option ${String.fromCharCode(65 + i)}`;
                        
                        if (point.config.correctAnswer === `option${i}`) {
                            option.selected = true;
                        }
                        
                        correctAnswerSelect.appendChild(option);
                    }
                });
            }
            
            // Ajouter les écouteurs pour le nombre de paires (Appariement)
            const pairCountSelect = document.getElementById('modal-pair-count');
            if (pairCountSelect) {
                pairCountSelect.addEventListener('change', function() {
                    const pairCount = parseInt(this.value);
                    const pairsContainer = document.getElementById('modal-pairs-container');
                    
                    // Générer les champs de paires
                    let pairsHTML = '';
                    for (let i = 0; i < pairCount; i++) {
                        const termValue = i < point.config.terms.length ? point.config.terms[i] : `Terme ${i + 1}`;
                        const defValue = i < point.config.definitions.length ? point.config.definitions[i] : `Définition ${i + 1}`;
                        
                        pairsHTML += `
                            <div class="option-group">
                                <div class="option-header">
                                    <div class="option-title">Paire ${i + 1}</div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="modal-term-${i}">Terme:</label>
                                    <input type="text" id="modal-term-${i}" class="form-input" value="${termValue}">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="modal-definition-${i}">Définition:</label>
                                    <input type="text" id="modal-definition-${i}" class="form-input" value="${defValue}">
                                </div>
                            </div>
                        `;
                    }
                    
                    pairsContainer.innerHTML = pairsHTML;
                });
            }
            
            // Gérer la fermeture du modal
            document.getElementById('modal-close').addEventListener('click', closeModal);
            document.getElementById('modal-cancel').addEventListener('click', closeModal);
            
            // Gérer la sauvegarde des modifications
            document.getElementById('modal-save').addEventListener('click', function() {
                // Récupérer l'ID du point en cours d'édition
                const currentPointId = parseInt(modal.dataset.currentPointId);
                savePointConfig(currentPointId);
                closeModal();
            });
        }

        // Fonction pour fermer le modal
        function closeModal() {
            const modal = document.getElementById('point-config-modal');
            
            // Vérifier s'il y a des données temporaires à restaurer
            const closeBtn = document.getElementById('modal-close');
            const cancelBtn = document.getElementById('modal-cancel');
            
            if (cancelBtn.dataset.oldPoint) {
                try {
                    // Restaurer l'ancien point si annulation
                    const oldPoint = JSON.parse(cancelBtn.dataset.oldPoint);
                    const pointIndex = appState.templateSettings.video.evaluationPoints.findIndex(p => p.id === oldPoint.id);
                    
                    if (pointIndex !== -1) {
                        appState.templateSettings.video.evaluationPoints[pointIndex] = JSON.parse(JSON.stringify(oldPoint));
                        
                        // Mettre à jour l'interface
                        renderEvaluationPoints();
                        renderTimelinePoints();
                    }
                    
                    // Nettoyer les données temporaires
                    cancelBtn.dataset.oldPoint = '';
                    closeBtn.dataset.oldPoint = '';
                } catch (e) {
                    console.error("Erreur lors de la restauration des données:", e);
                }
            }
            
            // Nettoyer l'ID du point en cours d'édition
            modal.dataset.currentPointId = '';
            
            // Fermer le modal
            modal.classList.remove('active');
        }

        // Fonction pour sauvegarder la configuration d'un point
        function savePointConfig(pointId) {
            // Trouver le point spécifique à modifier par son ID
            const pointIndex = appState.templateSettings.video.evaluationPoints.findIndex(p => p.id === pointId);
            if (pointIndex === -1) return;
            
            // Référence au point à modifier
            const point = appState.templateSettings.video.evaluationPoints[pointIndex];
            
            // Récupérer les valeurs du formulaire
            const time = parseInt(document.getElementById('modal-point-time').value);
            const type = document.getElementById('modal-point-type').value;
            const question = document.getElementById('modal-point-question').value;
            
            // Créer un nouvel objet point avec les valeurs de base mises à jour
            // plutôt que de modifier directement le point existant
            const updatedPoint = {
                id: pointId,
                time: time,
                type: type,
                config: {
                    question: question
                }
            };
            
            // Mettre à jour les propriétés spécifiques au type
            if (type === 'qcm') {
                const optionCount = parseInt(document.getElementById('modal-option-count').value);
                const options = [];
                
                for (let i = 0; i < optionCount; i++) {
                    const option = document.getElementById(`modal-option-${i}`).value;
                    options.push(option);
                }
                
                updatedPoint.config.options = options;
                updatedPoint.config.correctAnswer = document.getElementById('modal-correct-answer').value;
            } else if (type === 'calcul') {
                updatedPoint.config.formula = document.getElementById('modal-formula').value;
                updatedPoint.config.correctResult = parseFloat(document.getElementById('modal-correct-result').value);
            } else if (type === 'appariement') {
                const pairCount = parseInt(document.getElementById('modal-pair-count').value);
                const terms = [];
                const definitions = [];
                
                for (let i = 0; i < pairCount; i++) {
                    const term = document.getElementById(`modal-term-${i}`).value;
                    const definition = document.getElementById(`modal-definition-${i}`).value;
                    
                    terms.push(term);
                    definitions.push(definition);
                }
                
                updatedPoint.config.terms = terms;
                updatedPoint.config.definitions = definitions;
            }
            
            // Remplacer le point dans le tableau
            appState.templateSettings.video.evaluationPoints[pointIndex] = updatedPoint;
            
            // Mettre à jour l'interface
            renderEvaluationPoints();
            renderTimelinePoints();
            
            showNotification("Configuration du point enregistrée");
            
            // Nettoyer les données temporaires
            document.getElementById('modal-close').dataset.oldPoint = '';
            document.getElementById('modal-cancel').dataset.oldPoint = '';
        }

        // Fonction pour extraire l'ID de vidéo YouTube à partir de l'URL
        function extractYouTubeId(url) {
            if (!url) return null;
            
            // Format: https://www.youtube.com/watch?v=VIDEO_ID
            let match = url.match(/(?:\?v=|\/embed\/|\.be\/)([^&\n?#]+)/);
            
            // Format: https://youtu.be/VIDEO_ID
            if (!match) {
                match = url.match(/^https?:\/\/youtu\.be\/([^&\n?#]+)/);
            }
            
            // Format: VIDEO_ID (direct ID)
            if (!match && url.length === 11 && /^[a-zA-Z0-9_-]{11}$/.test(url)) {
                return url;
            }
            
            return match ? match[1] : null;
        }

        // Fonction pour charger l'API YouTube
        function loadYouTubeAPI() {
            if (youtubeApiLoaded) return;
            
            // Créer le script pour l'API YouTube
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            
            // Définir la fonction de callback pour YouTube
            window.onYouTubeIframeAPIReady = function() {
                youtubeApiLoaded = true;
                initializeYouTubePlayer();
            };
        }

        // Fonction pour initialiser le lecteur YouTube
        function initializeYouTubePlayer() {
            const videoId = appState.templateSettings.video.videoId;
            
            if (!videoId) {
                console.log("Aucun ID vidéo YouTube disponible");
                return;
            }
            
            if (player) {
                // Si le lecteur existe, charger la nouvelle vidéo
                player.loadVideoById({
                    videoId: videoId,
                    startSeconds: appState.templateSettings.video.startTime
                });
                player.pauseVideo(); // Pause automatique
            } else {
                // Créer un nouveau lecteur
                player = new YT.Player('yt-preview-player', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'autoplay': 0,
                        'controls': 1,
                        'rel': 0,
                        'fs': 1,
                        'modestbranding': 1,
                        'start': appState.templateSettings.video.startTime
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });
            }
        }

        // Fonction appelée quand le lecteur est prêt
        function onPlayerReady(event) {
            console.log("Lecteur YouTube prêt");
            updateCurrentTimeDisplay();
        }

        // Fonction appelée quand l'état du lecteur change
        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                // Mettre à jour l'affichage du temps actuel périodiquement
                startTimeUpdater();
            } else {
                // Arrêter la mise à jour du temps
                stopTimeUpdater();
            }
        }

        // Variables pour le suivi du temps
        let timeUpdateInterval = null;

        // Fonction pour démarrer la mise à jour du temps
        function startTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            
            timeUpdateInterval = setInterval(updateCurrentTimeDisplay, 100);
        }

        // Fonction pour arrêter la mise à jour du temps
        function stopTimeUpdater() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        // Fonction pour mettre à jour l'affichage du temps actuel
        function updateCurrentTimeDisplay() {
            if (!player) return;
            
            const currentTime = player.getCurrentTime();
            const display = document.getElementById('current-time-display');
            
            if (display) {
                display.textContent = `Position: ${formatTime(currentTime)}`;
            }
        }

        // Fonction pour créer un point à la position actuelle
        function createPointAtCurrentTime() {
            if (!player) return;
            
            const currentTime = Math.round(player.getCurrentTime());
            
            // Vérifier si le temps est dans les limites
            if (currentTime < appState.templateSettings.video.startTime || 
                currentTime > appState.templateSettings.video.endTime) {
                showNotification("Le temps actuel est en dehors des limites définies");
                return;
            }
            
            // Créer un nouveau point
            const newPoint = {
                id: Date.now(), // ID unique
                time: currentTime,
                type: "qcm", // Type par défaut
                config: {
                    question: `Question ${appState.templateSettings.video.evaluationPoints.length + 1}`,
                    options: ["Option A", "Option B", "Option C"],
                    correctAnswer: "option0"
                }
            };
            
            appState.templateSettings.video.evaluationPoints.push(newPoint);
            
            // Mettre à jour l'interface
            renderEvaluationPoints();
            renderTimelinePoints();
            
            showNotification(`Point d'évaluation créé à ${formatTime(currentTime)}`);
        }

        // Fonction pour mettre à jour la prévisualisation vidéo
        function updateVideoPreview() {
            const videoId = extractYouTubeId(document.getElementById('video-url').value);
            
            if (videoId) {
                appState.templateSettings.video.videoId = videoId;
                appState.templateSettings.video.videoUrl = document.getElementById('video-url').value;
                
                // Initialiser le lecteur YouTube si l'API est chargée
                if (youtubeApiLoaded) {
                    initializeYouTubePlayer();
                } else {
                    loadYouTubeAPI();
                }
                
                // Mettre à jour la timeline
                renderTimelinePoints();
            } else {
                showNotification("URL de vidéo YouTube invalide");
            }
        }

        // Fonction pour générer le prompt
        function generatePrompt() {
            // Afficher l'indicateur de chargement
            document.getElementById('loading-indicator').style.display = 'block';
            
            // Désactiver le bouton de génération
            document.getElementById('generate-prompt-btn').disabled = true;
            
            // Simuler un délai de génération
            setTimeout(() => {
                // Créer le prompt
                const prompt = createPrompt();
                
                // Afficher le prompt
                document.getElementById('prompt-preview').textContent = prompt;
                
                // Activer les boutons
                document.getElementById('copy-prompt-btn').disabled = false;
                document.getElementById('download-prompt-btn').disabled = false;
                document.getElementById('toggle-technical-btn').disabled = false;
                
                // Masquer l'indicateur de chargement
                document.getElementById('loading-indicator').style.display = 'none';
                
                // Réactiver le bouton de génération
                document.getElementById('generate-prompt-btn').disabled = false;
                
                // Sauvegarder le prompt généré
                appState.generatedPrompt = prompt;
                
                showNotification("Prompt généré avec succès!");
            }, 1500);
        }

        // Fonction pour créer le prompt
        function createPrompt() {
            // Construire le prompt principal
            let prompt = `# GÉNÉRATION D'APPLICATION VIDÉO INTERACTIVE SCORM

Veuillez créer une application SCORM interactive complète basée sur une vidéo YouTube avec des points d'évaluation selon les spécifications suivantes:

## INFORMATIONS GÉNÉRALES
- Titre: "${appState.title}"
- Description: "${appState.description}"
- Auteur: "${appState.author}"
- Matière/Sujet: "${appState.subject === 'custom' ? appState.customSubject : appState.subject}"
- Niveau de difficulté: ${appState.difficulty}
- Public cible: ${appState.audience}

## CONFIGURATION VIDÉO
- URL de la vidéo: ${appState.templateSettings.video.videoUrl}
- Temps de début: ${appState.templateSettings.video.startTime} secondes
- Temps de fin: ${appState.templateSettings.video.endTime} secondes

## POINTS D'ÉVALUATION
`;

            // Ajouter les points d'évaluation
            appState.templateSettings.video.evaluationPoints.forEach((point, index) => {
                prompt += `\n### Point d'évaluation ${index + 1}:\n`;
                prompt += `- Temps: ${point.time} secondes\n`;
                prompt += `- Type: ${point.type}\n`;
                prompt += `- Question: "${point.config.question}"\n`;
                
                if (point.type === 'qcm') {
                    prompt += `- Options:\n`;
                    point.config.options.forEach((option, i) => {
                        prompt += `  * Option ${String.fromCharCode(65 + i)}: "${option}"\n`;
                    });
                    prompt += `- Réponse correcte: Option ${String.fromCharCode(65 + parseInt(point.config.correctAnswer.replace('option', '')))}`;
                } else if (point.type === 'calcul') {
                    prompt += `- Formule: ${point.config.formula}\n`;
                    prompt += `- Résultat correct: ${point.config.correctResult}`;
                } else if (point.type === 'appariement') {
                    prompt += `- Paires:\n`;
                    for (let i = 0; i < point.config.terms.length; i++) {
                        prompt += `  * "${point.config.terms[i]}" -> "${point.config.definitions[i]}"\n`;
                    }
                }
            });

            prompt += `\n## CONTENU
- Instructions générales: "${appState.contentInstructions}"
${appState.contentTheme ? '- Thème du contenu: ' + appState.contentTheme : ''}

// =====================================================================
##0 ⚠️ IMPORTANT ! APPARENCE / THEME DE COULEUR DE L APPLICATION
// =====================================================================

- THEME DE COULEUR : ${appState.colorTheme}${appState.useCustomColor ? '\n- Couleur personnalisée: ' + appState.customPrimaryColor : ''}

## ⚠️ IMPORTANT UTILISER LA MEME COULEUR POUR LE FOND DE PAGE DE L APPLICATION : ${appState.colorTheme}

- COULEUR SECONDAIRE : POUR LES BOUTONS ET LES ACCENTUATIONS : ${appState.customPrimaryColor}

- Style d'interface: ${appState.uiStyle}
- Police: ${appState.fontFamily}

## FONCTIONNALITÉS
${Object.entries(appState.features).map(([key, value]) => `- ${key}: ${value ? 'Oui' : 'Non'}`).join('\n')}

// =====================================================================
##00 ⚠️ NOTES IMPORTANTES SUR LA GAMIFICATION
// =====================================================================
- LES BADGES DE GAMIFICATION SONT TOUJOURS PLACÉS EN DESSOUS DU HEADER
- LES BADGES SONT DÉBLOQUÉS AU FUR ET À MESURE DE LA PROGRESSION SEULEMENT SI LES RÉPONSES SONT CORRECTES

- Badges: ${appState.enableBadges ? 'Oui' : 'Non'}${appState.enableBadges ? '\n- Nombre de badges: ' + appState.badgeCount : ''}${appState.enableBadges ? '\n- Seuil de déblocage: ' + appState.badgeThreshold : ''}

// =====================================================================
###1 ⚠️ IMPORTANT : CODE HTML CSS ET JS POUR BADGES / NOMBRE MAXIMUM 6 / 
// =====================================================================

ADAPTER SELON NOMBRE DE BADGES : ${appState.badgeCount}

<###1-- CODE HTML BADGES --> 
<div class="badges-container">
    <div class="badge" id="badge1" data-level="Novice">🎓</div>
    <div class="badge" id="badge2" data-level="Confirmé">⭐</div>
    <div class="badge" id="badge3" data-level="Expert">🏆</div>
    <div class="badge" id="badge4" data-level="Maître">🏅</div>
    <div class="badge" id="badge5" data-level="Génie">🎖️</div>
    <div class="badge" id="badge6" data-level="Légende">👑</div>
</div>


<###2-- DEBUT CODE CSS BADGES --> 
/* Badge system */
.badges-container {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin: 15px 0;
}

.badge {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #2a2a2a;
    color: #888;
    font-size: 1.3em;
    transition: all 0.3s;
    position: relative;
    border: 2px solid #444;
}

.badge.unlocked {
    background: var(--primary-color);
    color: var(--bg-color);
    border-color: #fff;
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(254, 199, 0, 0.6);
}

.badge::after {
    content: attr(data-level);
    position: absolute;
    bottom: -8px;
    font-size: 0.7em;
    background: var(--card-bg);
    padding: 2px 8px;
    border-radius: 10px;
    color: #888;
}

.badge.unlocked::after {
    background: var(--primary-color);
    color: var(--bg-color);
}
<###2-- FIN CODE CSS BADGES --> 


<###3-- DEBUT CODE JAVASCRIPT BADGES --> 
/* 
// Variables pour le système de badges
let score = 0;
let solved = new Set();

// Mettre à jour les badges
function updateBadges() {
    const badges = [
        { id: 'badge1', threshold: 1 },
        { id: 'badge2', threshold: 2 },
        { id: 'badge3', threshold: 3 },
        { id: 'badge4', threshold: 4 },
        { id: 'badge5', threshold: 5 }
    ];
    
    badges.forEach(badge => {
        if (score >= badge.threshold) {
            document.getElementById(badge.id).classList.add('unlocked');
        }
    });
}

// Incrementer le score et mettre à jour les badges
function incrementScore() {
    score++;
    document.getElementById('score').textContent = score;
    solved.add(currentEvalPoint.id.toString());
    updateBadges();
}

// Fonction pour débloquer un badge spécifique
function unlockBadge(badgeId) {
    document.getElementById(badgeId).classList.add('unlocked');
}

// Fonction pour réinitialiser tous les badges
function resetBadges() {
    const badges = document.querySelectorAll('.badge');
    badges.forEach(badge => {
        badge.classList.remove('unlocked');
    });
    score = 0;
    solved.clear();
}

// Exemple d'utilisation:
// unlockBadge('badge1'); // Débloque le badge Novice
// updateBadges(); // Met à jour tous les badges selon le score actuel
*/
<###3-- FIN CODE JAVASCRIPT BADGES --> 


// =====================================================================
#0 ⚠️⚠️ OBLIGATOIRE : INSTRUCTIONS POUR LE CODE
// =====================================================================

1. Veuillez inclure dans votre réponse une application HTML complète et fonctionnelle qui implémente toutes les spécifications ci-dessus. 
2. L'application doit être autonome (un seul fichier HTML) et inclure tout le CSS et JavaScript nécessaire pour le fonctionnement de la vidéo interactive avec les points d'évaluation.
3. LE SCORE EST NOTE SUR 1 POINT PAR QUESTION
4. LE SCORE TOTAL EST LE NOMBRE DE QUESTIONS MULTIPLIE PAR 1 POINT
5. CHAQUE TENTATIVE DE REPONSE EST UNIQUE : LES AUTRES QUESTIONS DEVIENNENT INACTIVES
6. UN BOUTON FLOTTANT "TERMINER L ACTIVITE" EST EN BAS DE PAGE / ACTIVABLE UNE FOIS MEME SI TOUTES REPONSES NON DONNEES (message d'avertissement)


// =====================================================================
#1 ⚠️⚠️⚠️ ABSOLU :  CODE HTML DE L APPLICATION VIDEO INTERACTIVE
// =====================================================================

<###1 !-- CODE HTML DE L APPLICATION VIDEO INTERACTIVE--> 
</head>
<body>
    <div class="score-board">
        Score: <span class="score" id="score">0</span> / <span id="total">6</span>
    </div>
    
    <div class="container">
        <h1>Activité Vidéo Interactive</h1>
        <div class="typescorm">SCORM App</div>
        
        <div class="badges-container">
            <!-- Les badges seront insérés ici -->
        </div>
        
        <div class="player-container" id="playerContainer">
            <div class="video-container">
                <div id="player"></div>
                <!-- Overlay pour le début de vidéo -->
                <div class="video-overlay" id="videoStartOverlay">
                    La vidéo commence à .... secondes
                </div>
                <!-- Overlay pour la fin de vidéo -->
                <div class="video-overlay" id="videoEndOverlay" style="display: none;">
                    Vidéo terminée
                </div>
            </div>
        </div>
            
            <div class="activity-container" id="activityContainer">
                <!-- Le contenu des activités sera généré dynamiquement ici -->
            </div>
        </div>
        
        <div class="timeline" id="timeline">
            <div class="timeline-progress" id="timelineProgress"></div>
            <!-- Points d'évaluation générés dynamiquement -->
        </div>
        
        <button class="btn" id="finishBtn" disabled>Terminer l'activité</button>
    </div>
</body>
</html>
<###1 ! FIN CODE HTML DE L APPLICATION VIDEO INTERACTIVE -->


// =====================================================================
#2 ⚠️⚠️ OBLIGATOIRE !! ELEMENTS DE CODE FONCTIONNELS DE L'APPLICATION 
// =====================================================================

TRAITER RIGOUREUSEMENT TOUS LES ELEMENTS DE CODE SUIVANTS QUI DECRIVENT LE FONCTIONNEMENT ET LES 

##1 BOUTON DEMARRER LA VIDEO
##2 BOUTON PLEIN ECRAN
##3 FORMAT POUR EN TETE
##4 BOUTON TERMINER L ACTIVITE
##5 MODAL ET RESUME DE L ACTIVITE : EXERCICES / REUSSITE / OU ECHEC / OU NON COMPLETES
##6 ⚠️COMPATIBILITÉ SCORM
##7 JAVASCRIPT SPECIFIQUE AU TEMPLATE VIDEO INTERACTIVE
##8 CONFIGURATION POINTS EVALUATION
##9 ACTIVITÉ QCM 
##10 ACTIVITÉ CALCUL
##11 ACTIVITÉ APPARIEMENT 
##12 SI L ACTIVITE EST TERMINEE LES POINTS D EVALUATION SONT DESACTIVES
##13 FIN ET MODAL
##14 LE RESUME DES EXERCICES COHERENT AVEC LE SCORE 
##15 FERMETURE DU MODAL : SOIT EN CLIQUANT EN DEHORS OU EN CLIQUANT SUR FERMER
##16 BOUTON FERMER DU MODAL
##17 STRUCTURE DE L'APPLICATION 
##18 FONCTIONNALITES DE L'APPLICATION 
##19 CODE HTML DU TEMPLATE VIDEO INTERACTIVE


// =====================================================================
##1 ⚠️ IMPORTANT : BOUTON DEMARRER LA VIDEO  ==========
// =====================================================================

<###1 !-- CODE HTML BOUTON DEMARRER LA VIDEO --> 
<div class="video-container">
    <div class="video-overlay" id="videoStartOverlay">
        La vidéo commence à 20 secondes
    </div>
    <button class="start-video-btn" id="startVideoBtn">Démarrer la vidéo</button>
</div>

<###1 !-- FIN CODE HTML BOUTON DEMARRER LA VIDEO --> 

<###2 !-- CODE CSS BOUTON DEMARRER LA VIDEO --> 

.start-video-btn {
    display: block;
    width: 100%;
    max-width: 300px;
    padding: 12px 24px;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 30px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    text-align: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
}

.start-video-btn:hover {
    background: var(--primary-dark);
    transform: translate(-50%, -50%) translateY(-2px);
    box-shadow: 0 5px 15px rgba(123, 44, 191, 0.3);
}

<###2 !-- FIN CODE CSS BOUTON DEMARRER LA VIDEO --> 

<###3 !-- CODE JAVASCRIPT BOUTON DEMARRER LA VIDEO --> 
// Code désactivé pour éviter l'interférence
document.addEventListener('DOMContentLoaded', function() {
    const startBtn = document.getElementById('startVideoBtn');
    const videoOverlay = document.getElementById('videoStartOverlay');
    
    startBtn.onclick = function() {
        // Cacher l'overlay de départ
        videoOverlay.style.display = 'none';
        // Démarrer la vidéo (cette partie serait spécifique à votre lecteur vidéo)
        // player.playVideo();
        // Cacher le bouton
        startBtn.style.display = 'none';
    };
});
<###3 !-- FIN CODE JAVASCRIPT BOUTON DEMARRER LA VIDEO --> 


// =====================================================================
##2 ⚠️ PRIORITE HAUTE : FORMAT POUR BOUTON PLEIN ECRAN
// =====================================================================

<###1 !-- CODE HTML ICONE PLEIN ECRAN --> 
<div class="fullscreen-btn" id="fullscreenBtn">
    <span class="fullscreen-icon">⛶</span>
</div>
<###1 !-- FIN CODE HTML ICONE PLEIN ECRAN --> 

<###2 !-- CODE CSS ICONE PLEIN ECRAN -->
<style>
/* CSS pour le bouton "Plein écran" */
.fullscreen-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    background: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
    z-index: 1000;
}

.fullscreen-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 15px rgba(0,0,0,0.15);
}

.fullscreen-icon {
    font-size: 1.5em;
    color: #667eea; /* Couleur bleue, ajustez selon votre design */
}

/* Style supplémentaire pour le mode plein écran */
.fullscreen-container {
    width: 100%;
    height: 100vh;
    overflow-y: auto;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 20px;
}
</style>
<###2 !-- FIN CODE CSS ICONE PLEIN ECRAN -->

<###3 !-- CODE JAVASCRIPT ICONE PLEIN ECRAN -->
document.addEventListener('DOMContentLoaded', function() {
    // Initialisation du bouton plein écran
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    fullscreenBtn.addEventListener('click', toggleFullscreen);
    
    function toggleFullscreen() {
        if (!document.fullscreenElement && 
            !document.mozFullScreenElement && 
            !document.webkitFullscreenElement && 
            !document.msFullscreenElement) {
            // Passer en mode plein écran
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            } else if (document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
            updateFullscreenButton(true);
            document.body.classList.add('fullscreen-container');
        } else {
            // Quitter le mode plein écran
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
            updateFullscreenButton(false);
            document.body.classList.remove('fullscreen-container');
        }
    }
    
    function updateFullscreenButton(isFullscreen) {
        const iconElement = document.querySelector('.fullscreen-icon');
        if (isFullscreen) {
            iconElement.textContent = '⛝'; // Icône pour quitter le plein écran
        } else {
            iconElement.textContent = '⛶'; // Icône pour entrer en plein écran
        }
    }
    
    // Détection des changements de plein écran
    document.addEventListener('fullscreenchange', () => {
        updateFullscreenButton(!!document.fullscreenElement);
    });
    document.addEventListener('webkitfullscreenchange', () => {
        updateFullscreenButton(!!document.webkitFullscreenElement);
    });
    document.addEventListener('mozfullscreenchange', () => {
        updateFullscreenButton(!!document.mozFullScreenElement);
    });
    document.addEventListener('MSFullscreenChange', () => {
        updateFullscreenButton(!!document.msFullscreenElement);
    });

<###3 !-- FIN CODE JAVASCRIPT ICONE PLEIN ECRAN -->


// =====================================================================
##3 ⚠️ PRIORITE HAUTE : FORMAT POUR EN TETE HEADER##
// =====================================================================

- Voici le code pour les éléments du header de toutes les applications :
- A ADAPTER SELON LE THEME CHOISI

<###2 !-- CODE HTML EN TETE -->
##<head>##
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Éléments Header - Application d'appariement</title>
    <style>
        /* Styles généraux */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        /* Styles du header */
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        
        .typescorm {
            position: fixed;
            top: 60px;
            left: 60px;
            background-color: #1976d2;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            transform: translateY(-50%);
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }        
        
        .score-board {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            font-weight: bold;
            color: #333;
            z-index: 100;
        }
        
        .score {
            color: #667eea;
            font-size: 1.2em;
        }
        
        .formula-box {
            text-align: center;
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            color: #444;
        }
        
        .formula {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .formula-explanation {
            font-size: 0.9em;
            color: #666;
        }
        
        /* Media queries pour la responsivité */
        @media (max-width: 768px) {
            .score-board {
                position: static;
                margin-bottom: 20px;
                text-align: center;
            }
        }
    </style>


<###2 !-- CODE HTML EN TETE -->
</head>
<body>
    <!-- Exemple d'utilisation des éléments du header -->
    <div class="score-board">
        Score: <span class="score" id="score">0</span> / <span id="total">6</span>
    </div>
    
    <div class="container">
        <h1>🔗 Application 🎯</h1>
        
            <div class="typescorm">SCORM App</div>
            
        <div class="formula-box">
            <div class="formula">
                Appariement de termes et définitions
            </div>
            <div class="formula-explanation">
                Glissez chaque terme vers sa définition correspondante pour créer les bonnes paires.
            </div>
        </div>
        
        <!-- Contenu restant de l'application irait ici -->
    </div>

    <script>
        // Exemple minimal de script pour mettre à jour le score
        document.addEventListener('DOMContentLoaded', function() {
            // Cette fonction pourrait être utilisée pour mettre à jour le score
            function updateScore(newScore, total) {
                document.getElementById('score').textContent = newScore;
                document.getElementById('total').textContent = total;
            }
            
            // Exemple: mettre à jour le score après 2 secondes
            setTimeout(() => {
                updateScore(2, 6);
            }, 2000);
        });
</disabled_code>

// =====================================================================
##4 ⚠️ PRIORITE HAUTE : FORMAT POUR BOUTON TERMINER L ACTIVITE
// =====================================================================

<###1 !-- html Bouton de fin d'activité -->
<button id="finishBtn" class="finish-btn" disabled>Terminer l'activité</button>

<###2 !-- Bouton terminer l'activité (désactivé par défaut) -->
<div id="validation-message"></div>
<button id="finishBtn" class="finish-btn" disabled>Terminer l'activité</button>


<###3 !-- CODE CSS BOUTON TERMINER L ACTIVITE -->
/* Styles du bouton terminer */
.finish-btn {
    display: block;
    width: 100%;
    max-width: 300px;
    margin: 30px auto 0;
    padding: 15px;
    background: var(--primary-color);
    color: var(--bg-color);
    border: none;
    border-radius: 8px;
    font-size: 1.2em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
}

.finish-btn:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(254, 199, 0, 0.3);
}

.finish-btn:disabled {
    background: rgba(254, 199, 0, 0.3);
    color: rgba(0, 0, 0, 0.5);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* Message de validation */
#validation-message {
    display: none;
    padding: 15px;
    margin: 15px 0;
    border-radius: 8px;
    text-align: center;
}
<###3 ! fin css Bouton de fin d'activité -->
	
	
<###3 ! JavaScript pour le Bouton de fin d'activité" -->

// Mettre à jour l'état du bouton de fin
function updateFinishButton() {
    const finishBtn = document.getElementById('finishBtn');
    if (answered.size >= 1) {
        finishBtn.disabled = false;
    } else {
        finishBtn.disabled = true;
    }
}

// Terminer l'activité
function finishActivity() {
    // Vérifier si au moins une question est répondue
    if (answered.size === 0) {
        // Afficher un message d'erreur intégré à l'interface
        const validationMessage = document.getElementById('validation-message');
        validationMessage.style.display = 'block';
        validationMessage.style.backgroundColor = '#f8d7da';
        validationMessage.style.border = '1px solid #f5c6cb';
        validationMessage.style.color = '#721c24';
        validationMessage.textContent = "Vous devez répondre à au moins une question avant de terminer l'activité.";
        
        // Masquer le message après 5 secondes
        setTimeout(() => {
            validationMessage.style.display = 'none';
        }, 5000);
        return;
    }
    
    // Marquer le test comme terminé
    testCompleted = true;
    
    // SCORM: Marquer comme terminé
    setValue("cmi.completion_status", "completed");
    setValue("cmi.success_status", (score / totalExercises >= 0.7) ? "passed" : "failed");
    setValue("cmi.exit", "normal");
    
    // SCORM: Mettre à jour le temps de session
    updateSessionTime();
    
    // SCORM: Sauvegarder l'état final
    saveState();
    
    // SCORM: Effectuer un commit final
    commitSCORM();
    
    // Désactiver tous les inputs et boutons
    document.querySelectorAll('input, .check-btn, .finish-btn, .start-titration-btn, .prepare-titration-btn, select').forEach(el => {
        el.disabled = true;
    });
    
    // Afficher le modal de fin d'activité
    showCompletionModal();
}

// Code désactivé pour insertion dans prompt
/*
// Vérifier si toutes les questions ont été répondues
function checkAllQuestionsAnswered() {
    if (answeredQuestions.size === evaluationPoints.length) {
        document.getElementById('finishBtn').disabled = false;
        document.getElementById('finishBtn').scrollIntoView({ behavior: 'smooth' });
    }
}

// Activer le bouton quand la vidéo se termine (seulement si au moins une question répondue)
function onPlayerStateChange(event) {
    // Autres fonctionnalités...
    
    if (event.data === YT.PlayerState.ENDED) {
        // Vidéo terminée
        document.getElementById('videoEndOverlay').style.display = 'flex';
        
        // Activer le bouton de fin si au moins une question a été répondue
        if (answeredQuestions.size > 0) {
            document.getElementById('finishBtn').disabled = false;
        }
        
        document.getElementById('finishBtn').scrollIntoView({ behavior: 'smooth' });
    }
}

// Vérification lors du clic sur le bouton terminer
function finishActivity() {
    // Vérifier si au moins une question est répondue
    if (answeredQuestions.size === 0) {
        // Afficher un message d'erreur
        const validationMessage = document.getElementById('validation-message');
        validationMessage.style.display = 'block';
        validationMessage.style.backgroundColor = 'rgba(220, 53, 69, 0.2)';
        validationMessage.style.border = '1px solid rgba(220, 53, 69, 0.5)';
        validationMessage.style.color = '#dc3545';
        validationMessage.style.padding = '10px';
        validationMessage.style.borderRadius = '5px';
        validationMessage.style.margin = '15px 0';
        validationMessage.textContent = "Vous devez répondre à au moins une question avant de terminer l'activité.";
        
        // Masquer le message après 5 secondes
        setTimeout(() => {
            validationMessage.style.display = 'none';
        }, 5000);
        return;
    }
    
    // Suite du code de finalisation...
}
*/

// Afficher le modal de fin d'activité
function showCompletionModal() {
    // Mettre à jour les données du modal
    document.getElementById('modal-score').textContent = score;
    document.getElementById('modal-total').textContent = totalExercises;
    
    // Calculer le pourcentage
    const percentage = Math.round((score / totalExercises) * 100);
    document.getElementById('modal-badge').textContent = percentage + '%';
    
    // Définir si l'étudiant a réussi ou échoué (seuil à 70%)
    const isPassed = percentage >= 70;
    if (!isPassed) {
        document.getElementById('modal-badge').classList.add('failed');
    }
    
    // Mettre à jour le texte du score
    const scoreText = document.getElementById('modal-score-text');
    if (isPassed) {
        scoreText.textContent = "Félicitations ! Vous avez réussi l'activité.";
    } else {
        scoreText.textContent = "Vous n'avez pas atteint le score minimum requis de 70%.";
    }
    
    // Générer le résumé des exercices
    const summaryContainer = document.getElementById('exercise-summary');
    summaryContainer.innerHTML = '';
    
    for (let i = 0; i < totalExercises; i++) {
        const exerciseNum = i + 1;
        const isCompleted = answered.has(exerciseNum);
        
        const exerciseItem = document.createElement('div');
        exerciseItem.className = 'exercise-item';
       
        
        summaryContainer.appendChild(exerciseItem);
    }
		
    
    // Afficher le modal
    const modal = document.getElementById('completion-modal');
    modal.style.display = 'flex';
    
    // Ajouter l'événement de fermeture au bouton
    document.getElementById('close-modal-btn').addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    // Fermer le modal en cliquant en dehors
    modal.addEventListener('click', (event) => {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
}
<###4 !-- fin JavaScript pour le bouton fin d'activite --


// =====================================================================
##5 ⚠️ IMPORTANT : RESUME DE L ACTIVITE : EXERCICES REUSSITE OU ECHEC OU NON COMPLETES
// =====================================================================

<###1 !-- début code css résumé de fin d'activité -->

/* Variables de couleurs */
:root {
    --primary-color: ;
    --primary-dark: ;
    --primary-light: ;
    --secondary-color: ;
    --bg-color: #fff;
    --text-color: #333;
    --card-bg: #f8f9fa;
    --success-color: #28a745;
    --danger-color: #dc3545;
}

/* Styles pour le modal de fin d'activité */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    animation: fadeIn 0.3s ease-out;
}

.modal-content {
    background: white;
    border-radius: 20px;
    padding: 30px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 5px 30px rgba(0, 0, 0, 0.3);
    text-align: center;
    position: relative;
    animation: slideIn 0.4s ease-out;
}

.modal-header {
    margin-bottom: 20px;
}

.modal-header h2 {
    color: var(--primary-color);
    font-size: 2em;
    margin-bottom: 10px;
}

.modal-body {
    margin-bottom: 25px;
}

.modal-footer {
    margin-top: 20px;
    text-align: center;
}

.close-modal-btn {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 30px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 150px;
}

.close-modal-btn:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(230, 59, 122, 0.3);
}

.close-modal-btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(230, 59, 122, 0.4);
}

.modal-badge {
    position: absolute;
    top: -15px;
    right: -15px;
    width: 70px;
    height: 70px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--success-color);
    color: white;
    font-weight: bold;
    font-size: 1.2em;
    border-radius: 50%;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    border: 4px solid white;
}

.modal-badge.failed {
    background: var(--danger-color);
}

.score-result {
    font-size: 3em;
    font-weight: bold;
    color: var(--primary-color);
    margin: 15px 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.score-text {
    font-size: 1.2em;
    margin-bottom: 15px;
}

.exercise-summary {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
    text-align: left;
}

.exercise-item {
	display: flex;
	justify-content: space-between;
	padding: 8px 0;
	border-bottom: 1px solid #eee;
}

.exercise-item:last-child {
	border-bottom: none;
}

.exercise-status {
	font-weight: bold;
}

.status-completed {
	color: #28a745;  /* Vert pour les exercices réussis */
}

.status-incomplete {
	color: #dc3545;  /* Rouge pour les exercices échoués ou non répondus */
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { transform: translateY(-50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@media (max-width: 768px) {
    .modal-content {
        width: 95%;
        padding: 20px;
    }
    
    .modal-header h2 {
        font-size: 1.5em;
    }
    
    .score-result {
        font-size: 2.5em;
    }


<###& ! fin code css résumé de fin d'activité -->


<###2 ! début code html moadl et résumé de fin d'activité -->

<div id="completion-modal" class="modal-overlay">
    <div class="modal-content">
        <div id="modal-badge" class="modal-badge">70%</div>
        <div class="modal-header">
            <h2>Activité terminée !</h2>
            <p>Vous avez complété les exercices</p>
        </div>
        <div class="modal-body">
            <div class="score-result">
                <span id="modal-score">0</span>/<span id="modal-total">6</span>
            </div>
            <p class="score-text" id="modal-score-text">Vous avez réussi l'activité.</p>
            
            <div class="exercise-summary" id="exercise-summary">
                <!-- Les éléments seront générés dynamiquement -->
                
			## EXEMPLE EXERCICE REUSSI
            <span class="exercise-status status-completed">✓ Réussi</span>
                
            ## EXEMPLE EXERCICE ECHEC
            <span class="exercise-status status-incomplete">✗ Non réussi</span>

            ## EXEMPLE EXERCICE NON COMPLETE
            <span class="exercise-status status-incomplete">✗ non complété</span>
                
                
            </div>
        </div>
        <div class="modal-footer">
            <button id="close-modal-btn" class="close-modal-btn">Fermer</button>
        </div>
    </div>
</div>

<###2 ! fin code html modal et résumé de fin d'activité -->

<###3 ! début code javascript résumé de fin d'activité -->
/* 
// ATTENTION: Ce code est désactivé par commentaires pour éviter toute interférence
// avec le code principal. Retirez les commentaires /* */ pour l'activer.

// Fonction pour afficher le modal de fin d'activité
function showCompletionModal() {
    // Mettre à jour les données du modal
    document.getElementById('modal-score').textContent = score;
    document.getElementById('modal-total').textContent = totalExercises;
    
    // Calculer le pourcentage
    const percentage = Math.round((score / totalExercises) * 100);
    document.getElementById('modal-badge').textContent = percentage + '%';
    
    // Définir si l'étudiant a réussi ou échoué (seuil à 70%)
    const isPassed = percentage >= 70;
    if (!isPassed) {
        document.getElementById('modal-badge').classList.add('failed');
    } else {
        // S'assurer de retirer la classe 'failed' si elle existait déjà
        document.getElementById('modal-badge').classList.remove('failed');
    }
    
    // Mettre à jour le texte du score
    const scoreText = document.getElementById('modal-score-text');
    if (isPassed) {
        scoreText.textContent = "Félicitations ! Vous avez réussi l'activité.";
    } else {
        scoreText.textContent = "Vous n'avez pas atteint le score minimum requis de 70%.";
    }
    
    // Générer le résumé des exercices
    const summaryContainer = document.getElementById('exercise-summary');
    summaryContainer.innerHTML = '';
    
    for (let i = 1; i <= totalExercises; i++) {
        const isCompleted = solved.has(i.toString());
        
        const exerciseItem = document.createElement('div');
        exerciseItem.className = 'exercise-item';
        exerciseItem.innerHTML = 
            "<span>Question " + i + "</span>" + 
            "<span class='exercise-status " + (isCompleted ? "status-completed" : "status-incomplete") + "'>" +
            (isCompleted ? "✓ Réussi" : "✗ Non réussi") +
            "</span>";
        
        summaryContainer.appendChild(exerciseItem);
    }
    
    // Afficher le modal
    document.getElementById('completion-modal').style.display = 'flex';
}

// Gestionnaires d'événements pour le modal
document.addEventListener('DOMContentLoaded', function() {
    // Ajouter l'événement de fermeture au bouton du modal
    document.getElementById('close-modal-btn').addEventListener('click', () => {
        document.getElementById('completion-modal').style.display = 'none';
    });
    
    // Fermer le modal en cliquant en dehors
    document.getElementById('completion-modal').addEventListener('click', (event) => {
        if (event.target === document.getElementById('completion-modal')) {
            document.getElementById('completion-modal').style.display = 'none';
        }
    });
});
*/

<###3 ! début code javascript résumé de fin d'activité -->


// =====================================================================
##6 ⚠️⚠️⚠️ PRIORITE ABOLUE : COMPATIBILITÉ SCORM
// =====================================================================

## COMPATIBILITÉ SCORM
L'application doit être compatible avec le standard SCORM 2004, en implémentant:
- Initialisation et détection automatique de l'API SCORM
- Suivi du temps de session
- Sauvegarde et restauration de l'état
- Enregistrement des interactions
- Gestion du score et de la progression
- Achèvement de l'activité

L'application doit être compatible avec le standard SCORM 2004, en implémentant:
###1. Initialisation et détection automatique de l'API SCORM
###2. Suivi du temps de session
###3. Sauvegarde et restauration de l'état
###4. Enregistrement des interactions
###5. Gestion du score et de la progression
###6. Achèvement de l'activité

<code_commun>
// Fonctions communes pour toutes les applications SCORM
// Gestion du SCORM, de l'interface utilisateur, etc.

// Variables globales SCORM
let API = null;
let API_1484_11 = null;
const scormVersion = "2004";
let initialized = false;
let terminated = false;
let lastError = "";
let suspendData = "";
let entryStatus = "ab-initio";
let sessionStartTime = Date.now();
let totalTime = 0;
let lastTimeUpdate = sessionStartTime;
let timeInterval = null;

// Variables globales de l'application
let score = 0;
let solved = new Set();
let allExercisesCompleted = false;

// Initialisation SCORM
function initSCORM() {
    if (initialized) return true;
    
    // Trouver l'API SCORM 2004
    API_1484_11 = findAPI(window);
    
    if (!API_1484_11) {
        console.error("SCORM API non trouvée");
        return false;
    }
    
    // Initialiser la communication
    let result = API_1484_11.Initialize("");
    
    if (result === "true" || result === true) {
        console.log("SCORM API initialisée avec succès");
        initialized = true;
        
        // Récupérer l'état précédent si disponible
        entryStatus = getValue("cmi.entry");
        suspendData = getValue("cmi.suspend_data");
        
        // Récupérer les données sauvegardées si elles existent
        if (suspendData) {
            try {
                restoreState(suspendData);
            } catch (e) {
                console.error("Erreur lors de la restauration des données:", e);
            }
        }
        
        return true;
    } else {
        console.error("Échec de l'initialisation SCORM");
        getLastError();
        return false;
    }
}

// Trouver l'API SCORM
function findAPI(win) {
    if (win.API_1484_11) return win.API_1484_11;
    
    let findAPITries = 0;
    while (win.parent && win.parent != win && findAPITries < 10) {
        findAPITries++;
        win = win.parent;
        if (win.API_1484_11) return win.API_1484_11;
    }
    
    let frames = win.frames;
    for (let i = 0; i < frames.length; i++) {
        let api = findAPI(frames[i]);
        if (api) return api;
    }
    
    return null;
}

// Sauvegarder l'état de l'application
function saveState() {
    if (!initialized) return;
    
    // Créer un objet avec toutes les données à sauvegarder
    const stateData = {
        score: score,
        solved: Array.from(solved),
        allExercisesCompleted: allExercisesCompleted
    };
    
    // Convertir en JSON
    suspendData = JSON.stringify(stateData);
    
    // Sauvegarder dans SCORM
    setValue("cmi.suspend_data", suspendData);
    
    // Sauvegarder le score actuel
    saveScore();
    
    // Sauvegarder l'état de progression
    saveProgress();
    
    // Commit immédiat pour assurer la persistance des données
    commitSCORM();
    
    console.log("État sauvegardé avec succès");

// =====================================================================
##7 ⚠️⚠️ CRITIQUE : CODE JAVASCRIPT SPECIFIQUE AU TEMPLATE VIDEO INTERACTIVE
// =====================================================================		

document.addEventListener('DOMContentLoaded', function() {
    // Initialisation des variables globales
    let player;                      // Objet du lecteur YouTube
    let videoId = '';                // ID de la vidéo YouTube
    let startTime = 0;               // Temps de début de la vidéo
    let endTime = 60;                // Temps de fin de la vidéo (60 secondes par défaut)
    let evaluationPoints = [];       // Liste des points d'évaluation
    let currentEvalPoint = null;     // Point d'évaluation actuel
    let videoStarted = false;        // Indique si la vidéo a été démarrée
    let answeredQuestions = new Set(); // Questions déjà répondues
    let videoCheckInterval = null;   // Intervalle de vérification vidéo
    let activityCompleted = false;   // Indique si l'activité est terminée
    
    // Variables globales de l'application
    let score = 0;
    let solved = new Set();
    let allExercisesCompleted = false;
    
    // Configuration initiale
    configureVideo("VIDEO_URL_PLACEHOLDER", 0, 60);
    
    // Configurer les points d'évaluation
    const points = [
        {
            id: 1,
            time: 15,
            type: 'qcm',
            config: {
                question: "Question de test ?",
                options: [
                    "Option A",
                    "Option B",
                    "Option C"
                ],
                correctAnswer: "option0"
            }
        },
        {
            id: 2,
            time: 30,
            type: 'calcul',
            config: {
                question: "Calculez la valeur de X.",
                formula: "X = A × B",
                values: {
                    A: 5,
                    B: 7
                },
                correctAnswer: 35,
                tolerance: 0.01
            }
        },
        {
            id: 3,
            time: 45,
            type: 'appariement',
            config: {
                pairs: [
                    {
                        term: "HTML",
                        definition: "Langage de balisage pour créer des pages web"
                    },
                    {
                        term: "CSS",
                        definition: "Langage de style pour mettre en forme les pages web"
                    },
                    {
                        term: "JavaScript",
                        definition: "Langage de programmation pour rendre les pages web interactives"
                    }
                ]
            }
        }
    ];
    
    configureEvaluationPoints(points);
    
    // Fonction pour extraire l'ID YouTube à partir d'une URL
    function extractYouTubeId(url) {
        const videoIdMatch = url.match(/(?:youtube\\.com\\/(?:[^\\/]+\\/.+\\/|(?:v|e(?:mbed)?)\\/|.*[?&]v=)|youtu\\.be\\/)([^"&?\\/ ]{11})/);
        return videoIdMatch ? videoIdMatch[1] : null;
    }
    
    // Fonction pour configurer la vidéo
    function configureVideo(videoUrl, startTimeInSeconds, endTimeInSeconds) {
        const extractedId = extractYouTubeId(videoUrl);
        if (!extractedId) {
            console.error("URL YouTube non valide");
            return;
        }
        
        videoId = extractedId;
        startTime = startTimeInSeconds || 0;
        endTime = endTimeInSeconds || 60;
        
        // Si l'API est déjà chargée, créer le lecteur
        if (typeof YT !== 'undefined' && YT.Player) {
            createYouTubePlayer(videoId, startTime);
        } else {
            // Charger l'API YouTube
            loadYouTubeAPI();
        }
    }
    
    // Fonction pour charger l'API YouTube
    function loadYouTubeAPI() {
        // Création du script pour l'API YouTube
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        
        // Définir la fonction globale pour YouTube
        window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
    }
    
    // Fonction appelée quand l'API YouTube est prête
    function onYouTubeIframeAPIReady() {
        console.log("API YouTube prête");
        if (videoId) {
            createYouTubePlayer(videoId, startTime);
        }
    }
    
    // Créer le lecteur YouTube
    function createYouTubePlayer(videoId, startSeconds) {
        if (player) {
            player.destroy();
        }
        
        player = new YT.Player('player', {
            height: '100%',
            width: '100%',
            videoId: videoId,
            playerVars: {
                'autoplay': 0,
                'controls': 1,
                'rel': 0,
                'start': startSeconds,
                'modestbranding': 1
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }
    
    // Fonction appelée quand le lecteur est prêt
    function onPlayerReady(event) {
        console.log("Lecteur YouTube prêt");
        
        // Ajouter un bouton de démarrage
        const startBtn = document.createElement('button');
        startBtn.className = 'btn';
        startBtn.textContent = 'Démarrer la vidéo';
        startBtn.style.position = 'absolute';
        startBtn.style.top = '50%';
        startBtn.style.left = '50%';
        startBtn.style.transform = 'translate(-50%, -50%)';
        startBtn.style.zIndex = '100';
        
        startBtn.onclick = function() {
			// Cacher l'overlay de départ
			document.getElementById('videoStartOverlay').style.display = 'none';
            player.playVideo();
            videoStarted = true;
            startBtn.remove();
        };
        
        document.getElementById('playerContainer').appendChild(startBtn);
    }
    
    // Fonction appelée quand l'état du lecteur change
    function onPlayerStateChange(event) {
        // YT.PlayerState.PLAYING = 1
        if (event.data === YT.PlayerState.PLAYING && videoStarted) {
            startVideoChecking();
            updateTimeline();
        } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
            stopVideoChecking();
        }
        
        if (event.data === YT.PlayerState.ENDED) {
            // Vidéo terminée
            document.getElementById('videoEndOverlay').style.display = 'flex';
            document.getElementById('finishBtn').disabled = false;
            document.getElementById('finishBtn').scrollIntoView({ behavior: 'smooth' });
        }
    }
    
// =====================================================================
##8 ⚠️⚠️⚠️ PRIORITE ABSOLUE : FONCTION POUR CONFIGURER POINTS EVALUATION
// =====================================================================	
    
    // Fonction pour configurer les points d'évaluation
    function configureEvaluationPoints(points) {
        evaluationPoints = points;
        document.getElementById('total').textContent = points.length;
        renderTimelinePoints();
    }
    
    // Fonction pour rendre les points d'évaluation dans la timeline
    function renderTimelinePoints() {
        const timeline = document.getElementById('timeline');
        if (!timeline) return;
        
        // Vider la timeline (sauf la barre de progression)
        const timelineProgress = document.getElementById('timelineProgress');
        timeline.innerHTML = '';
        timeline.appendChild(timelineProgress);
        
        // Ajouter chaque point d'évaluation
        evaluationPoints.forEach(point => {
            const position = (point.time / endTime) * 100;
            const pointElement = document.createElement('div');
            pointElement.className = 'timeline-point';
            pointElement.setAttribute('data-time', point.time);
            pointElement.setAttribute('data-type', point.type);
            pointElement.style.left = position + '%';
            
            // Ajouter une lettre selon le type
            let typeIndicator = '?';
            if (point.type === 'qcm') typeIndicator = 'Q';
            else if (point.type === 'calcul') typeIndicator = 'C';
            else if (point.type === 'appariement') typeIndicator = 'A';
            
            // Créer le label du point
            const label = document.createElement('span');
            label.className = 'timeline-label';
            label.textContent = typeIndicator + ' - ' + formatTime(point.time);
            
            // Ajouter le type dans le point
            const typeSpan = document.createElement('span');
            typeSpan.textContent = typeIndicator;
            
            pointElement.appendChild(typeSpan);
            pointElement.appendChild(label);
            
            // Marquer comme complété si déjà répondu
            if (answeredQuestions.has(point.id)) {
                pointElement.classList.add('completed');
            }
            
            timeline.appendChild(pointElement);
        });
    }
    
    // Démarrer la vérification de la vidéo
    function startVideoChecking() {
        if (videoCheckInterval) return;
        
        videoCheckInterval = setInterval(() => {
            if (!player || player.getPlayerState() !== YT.PlayerState.PLAYING) {
                return;
            }
            
            const currentTime = player.getCurrentTime();
            
            // Vérifier la fin
            if (endTime > 0 && currentTime >= endTime) {
                player.pauseVideo();
                stopVideoChecking();
                
                // Afficher l'overlay de fin
                document.getElementById('videoEndOverlay').style.display = 'flex';
                document.getElementById('finishBtn').disabled = false;
                document.getElementById('finishBtn').scrollIntoView({ behavior: 'smooth' });
                return;
            }
            
            // Vérifier les points d'évaluation
            if (!document.getElementById('activityContainer').classList.contains('active')) {
                for (const point of evaluationPoints) {
                    if (!answeredQuestions.has(point.id) && 
                        Math.abs(currentTime - point.time) < 0.5) {
                        player.pauseVideo();
                        showActivity(point);
                        break;
                    }
                }
            }
        }, 500);
    }
    
    function stopVideoChecking() {
        if (videoCheckInterval) {
            clearInterval(videoCheckInterval);
            videoCheckInterval = null;
        }
    }
    
    // Mettre à jour la timeline
    function updateTimeline() {
        if (!player) return;
        
        const interval = setInterval(() => {
            if (!player || player.getPlayerState() !== YT.PlayerState.PLAYING) {
                clearInterval(interval);
                return;
            }
            
            const currentTime = player.getCurrentTime();
            const progress = (currentTime / endTime) * 100;
            document.getElementById('timelineProgress').style.width = progress + '%';
        }, 100);
    }
    
    // Afficher une activité
    function showActivity(point) {
        currentEvalPoint = point;
        const container = document.getElementById('activityContainer');
        container.innerHTML = '';
        
        switch (point.type) {
            case 'qcm':
                renderQCMActivity(point);
                break;
            case 'calcul':
                renderCalculActivity(point);
                break;
            case 'appariement':
                renderMatchingActivity(point);
                break;
        }
        
        container.classList.add('active');
        container.scrollIntoView({ behavior: 'smooth' });
    }
    
// =====================================================================
##9 ⚠️⚠️ PRIORITE HAUTE : ACTIVITÉ QCM 
// =====================================================================	
    
    
    // Afficher une activité QCM
    function renderQCMActivity(point) {
        const container = document.getElementById('activityContainer');
        
        let html = \`
            <div class="activity-header">Question \${point.id} - QCM</div>
            <div class="activity-question">\${point.config.question}</div>
            <div class="qcm-options">
        \`;
        
        point.config.options.forEach((option, index) => {
            html += \`<div class="qcm-option" data-value="option\${index}">\${option}</div>\`;
        });
        
        html += \`
            </div>
            <button class="btn" id="validateQCMBtn">Valider</button>
            <div class="hint">💡 Réfléchissez bien avant de choisir votre réponse.</div>
            <div class="feedback"></div>
        \`;
        
        container.innerHTML = html;
        
        // Ajouter les événements
        container.querySelectorAll('.qcm-option').forEach(option => {
            option.addEventListener('click', function() {
                container.querySelectorAll('.qcm-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
            });
        });
        
        // Ajouter l'événement de validation
        document.getElementById('validateQCMBtn').addEventListener('click', validateQCM);
    }
    
    // Vérifier une réponse QCM
    function validateQCM() {
        const selected = document.querySelector('.qcm-option.selected');
        if (!selected) {
            alert('Veuillez sélectionner une réponse');
            return;
        }
        
        const value = selected.dataset.value;
        const isCorrect = value === currentEvalPoint.config.correctAnswer;
        
        if (isCorrect) {
            selected.classList.add('correct');
            incrementScore();
            showFeedback(true, 'Bravo ! C\\'est la bonne réponse.');
        } else {
            selected.classList.add('incorrect');
            showFeedback(false, 'Désolé, ce n\\'est pas la bonne réponse.');
        }
        
        answeredQuestions.add(currentEvalPoint.id);
        disableActivity();
        markTimelineComplete(currentEvalPoint.id);
        
        setTimeout(() => {
            continueVideo();
        }, 2000);
    }
    
    
// =====================================================================
##10 ⚠️⚠️ PRIORITE HAUTE : ACTIVITÉ CALCUL
// =====================================================================	
    
    // Afficher une activité de calcul
    function renderCalculActivity(point) {
        const container = document.getElementById('activityContainer');
        
        let html = \`
            <div class="activity-header">Question \${point.id} - Calcul</div>
            <div class="activity-question">\${point.config.question}</div>
            <div class="formula-display">\${point.config.formula}</div>
            <div class="calc-values">
        \`;
        
        for (const [key, value] of Object.entries(point.config.values)) {
            html += \`
                <div class="calc-value">
                    <div class="calc-value-label">\${key} =</div>
                    <div class="calc-value-num">\${value}</div>
                </div>
            \`;
        }
        
        html += \`
            </div>
            <input type="number" class="calc-input" id="calcAnswer" placeholder="Votre réponse">
            <button class="btn" id="validateCalcBtn">Valider</button>
            <div class="hint">💡 Appliquez la formule avec les valeurs données.</div>
            <div class="feedback"></div>
        \`;
        
        container.innerHTML = html;
        
        // Ajouter l'événement de validation
        document.getElementById('validateCalcBtn').addEventListener('click', validateCalc);
        
        // Valider au presser de Enter
        document.getElementById('calcAnswer').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                validateCalc();
            }
        });
    }
    
    // Vérifier une réponse de calcul
    function validateCalc() {
        const input = document.getElementById('calcAnswer');
        const answer = parseFloat(input.value);
        
        if (isNaN(answer)) {
            alert('Veuillez entrer un nombre valide');
            return;
        }
        
        const correctAnswer = currentEvalPoint.config.correctAnswer;
        const tolerance = Math.abs(correctAnswer) * 0.01;
        const isCorrect = Math.abs(answer - correctAnswer) <= tolerance;
        
        if (isCorrect) {
            incrementScore();
            showFeedback(true, 'Excellent ! C\\'est le bon résultat.');
        } else {
            showFeedback(false, \`Désolé, la bonne réponse était \${correctAnswer}.\`);
        }
        
        answeredQuestions.add(currentEvalPoint.id);
        disableActivity();
        markTimelineComplete(currentEvalPoint.id);
        
        setTimeout(() => {
            continueVideo();
        }, 2000);
    }
    
// =====================================================================
##11 ⚠️⚠️ PRIORITE HAUTE :ACTIVITÉ APPARIEMENT 
// =====================================================================	
    
    // Afficher une activité d'appariement
    function renderMatchingActivity(point) {
        const container = document.getElementById('activityContainer');
        
        // Mélanger les termes et définitions
        const terms = [...point.config.pairs].sort(() => Math.random() - 0.5);
        const definitions = [...point.config.pairs].sort(() => Math.random() - 0.5);
        
        let html = \`
            <div class="activity-header">Question \${point.id} - Appariement</div>
            <div class="activity-question">\${point.config.question}</div>
            <div class="matching-container">
                <div class="matching-column" id="termsColumn">
                    <h3>Termes</h3>
        \`;
        
        terms.forEach((item, index) => {
            html += \`<div class="term-block" draggable="true" data-term="\${item.term}">\${item.term}</div>\`;
        });
        
        html += \`
                </div>
                <div class="matching-column" id="definitionsColumn">
                    <h3>Définitions</h3>
        \`;
        
        definitions.forEach((item, index) => {
            html += \`<div class="definition-zone" data-definition="\${item.definition}">
                        <div class="definition-text">\${item.definition}</div>
                     </div>\`;
        });
        
        html += \`
                </div>
            </div>
            <button class="btn" id="validateMatchingBtn">Valider</button>
            <div class="hint">💡 Glissez les termes vers leurs définitions correspondantes.</div>
            <div class="feedback"></div>
        \`;
        
        container.innerHTML = html;
        
        // Ajouter l'événement de validation
        document.getElementById('validateMatchingBtn').addEventListener('click', validateMatching);
        
        // Configurer le drag and drop
        setupDragAndDrop();
    }
    
    // Configurer le drag and drop pour l'appariement
    function setupDragAndDrop() {
        const draggables = document.querySelectorAll('.term-block');
        const droppables = document.querySelectorAll('.definition-zone');
        
        draggables.forEach(draggable => {
            draggable.addEventListener('dragstart', handleDragStart);
            draggable.addEventListener('dragend', handleDragEnd);
        });
        
        droppables.forEach(droppable => {
            droppable.addEventListener('dragover', handleDragOver);
            droppable.addEventListener('dragenter', handleDragEnter);
            droppable.addEventListener('dragleave', handleDragLeave);
            droppable.addEventListener('drop', handleDrop);
        });
    }
    
    // Variables pour le drag and drop
    let draggedElement = null;
    
    function handleDragStart(e) {
        // Ne pas démarrer le drag si on a cliqué sur la croix de suppression
        if (e.target.classList.contains('delete-btn')) {
            return;
        }
        
        draggedElement = e.target;
        e.dataTransfer.setData('text/plain', e.target.getAttribute('data-term'));
        
        setTimeout(() => {
            e.target.classList.add('dragging');
        }, 0);
    }
    
    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
    }
    
    function handleDragOver(e) {
        e.preventDefault();
    }
    
    function handleDragEnter(e) {
        e.preventDefault();
        if (e.target.classList.contains('definition-zone')) {
            e.target.classList.add('drag-over');
        } else if (e.target.parentElement.classList.contains('definition-zone')) {
            e.target.parentElement.classList.add('drag-over');
        }
    }
    
    function handleDragLeave(e) {
        if (e.target.classList.contains('definition-zone')) {
            e.target.classList.remove('drag-over');
        } else if (e.target.parentElement.classList.contains('definition-zone')) {
            e.target.parentElement.classList.remove('drag-over');
        }
    }
    
    function handleDrop(e) {
        e.preventDefault();
        
        const dropZone = e.target.closest('.definition-zone');
        if (!dropZone) return;
        
        dropZone.classList.remove('drag-over');
        
        // Si la zone contient déjà un terme, ne rien faire
        if (dropZone.classList.contains('filled')) {
            return;
        }
        
        // Créer l'élément pour le terme associé
        const pairedTerm = document.createElement('div');
        pairedTerm.className = 'paired-term';
        pairedTerm.textContent = draggedElement.textContent;
        pairedTerm.dataset.term = draggedElement.dataset.term;
        
        // Ajouter le terme avant la définition
        const definitionText = dropZone.querySelector('.definition-text');
        dropZone.insertBefore(pairedTerm, definitionText);
        
        // Marquer la zone comme remplie
        dropZone.classList.add('filled');
        
        // Ajouter le bouton de suppression
        addDeleteButton(dropZone);
        
        // Supprimer le terme de sa position d'origine
        draggedElement.remove();
    }
    
    function addDeleteButton(zone) {
        // Vérifier si la zone a déjà un bouton de suppression
        if (zone.querySelector('.delete-btn')) {
            return;
        }
        
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            
            const pairedTerm = zone.querySelector('.paired-term');
            if (!pairedTerm) return;
            
            // Récréer le bloc de terme
            const termBlock = document.createElement('div');
            termBlock.className = 'term-block';
            termBlock.draggable = true;
            termBlock.dataset.term = pairedTerm.dataset.term;
            termBlock.textContent = pairedTerm.textContent;
            
            // Ajouter les événements
            termBlock.addEventListener('dragstart', handleDragStart);
            termBlock.addEventListener('dragend', handleDragEnd);
            
            // Remettre le terme dans son conteneur d'origine
            const termsContainer = document.getElementById('termsColumn');
            termsContainer.appendChild(termBlock);
            
            // Nettoyer la zone de définition
            pairedTerm.remove();
            deleteBtn.remove();
            zone.classList.remove('filled', 'correct', 'incorrect');
        });
        
        zone.appendChild(deleteBtn);
    }
    
    // Vérifier les associations
    function validateMatching() {
        const definitionZones = document.querySelectorAll('.definition-zone');
        let correctCount = 0;
        let allFilled = true;
        
        definitionZones.forEach(zone => {
            // Réinitialiser les classes de feedback
            zone.classList.remove('correct', 'incorrect');
            
            if (!zone.classList.contains('filled')) {
                allFilled = false;
                return;
            }
            
            const pairedTerm = zone.querySelector('.paired-term');
            const termText = pairedTerm ? pairedTerm.dataset.term : "";
            const definitionText = zone.dataset.definition;
            
            // Vérifier si l'association est correcte
            const isCorrect = currentEvalPoint.config.pairs.some(pair => 
                pair.term === termText && pair.definition === definitionText
            );
            
            if (isCorrect) {
                zone.classList.add('correct');
                correctCount++;
            } else {
                zone.classList.add('incorrect');
            }
        });
        
        if (!allFilled) {
            showFeedback(false, "⚠️ Associez tous les termes avant de vérifier");
            return;
        }
        
        if (correctCount === definitionZones.length) {
            incrementScore();
            showFeedback(true, "✅ Parfait ! Toutes les associations sont correctes !");
        } else {
            showFeedback(false, \`❌ \${correctCount}/\${definitionZones.length} associations correctes. Vérifiez les zones en rouge.\`);
        }
        
        answeredQuestions.add(currentEvalPoint.id);
        disableActivity();
        markTimelineComplete(currentEvalPoint.id);
        
        setTimeout(() => {
            continueVideo();
        }, 2000);
    }
    
    // Continuer la lecture de la vidéo
    function continueVideo() {
        document.getElementById('activityContainer').classList.remove('active');
        if (player && videoStarted) {
            player.playVideo();
        }
        
        // Vérifier si toutes les questions ont été répondues
        if (answeredQuestions.size === evaluationPoints.length) {
            document.getElementById('finishBtn').disabled = false;
        }
    }
    
    // Formater le temps en mm:ss
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return \`\${mins}:\${secs < 10 ? '0' + secs : secs}\`;
    }
    
    // Montrer le feedback
    function showFeedback(isCorrect, message) {
        const feedback = document.querySelector('#activityContainer .feedback');
        feedback.textContent = message;
        feedback.className = 'feedback show ' + (isCorrect ? 'correct' : 'incorrect');
        
        const hint = document.querySelector('#activityContainer .hint');
        if (hint) {
            hint.classList.add('show');
        }
    }
    
// =====================================================================
##12 ⚠️ PRIORITE HAUTE : SI L ACTIVITE EST TERMINEE LES POINTS D EVALUATION SONT DESACTIVES
// =====================================================================	
    
// Module de gestion de fin d'activité et désactivation des questions
const activityManager = (function() {
    // Variables privées
    let answeredQuestions = new Set();
    let score = 0;
    let activityCompleted = false;
    let evaluationPoints = [];
    let player = null;
    let videoStarted = false;
    
    // Initialisation du gestionnaire
    function init(videoPlayerRef, evalPoints) {
        player = videoPlayerRef;
        evaluationPoints = evalPoints;
        
        // Configurer le bouton de fin d'activité
        document.getElementById('finishBtn').addEventListener('click', finishActivity);
        document.getElementById('finishBtn').disabled = true;
        
		// Configurer l'événement de fermeture du modal
		document.getElementById('close-modal-btn').addEventListener('click', () => {
			document.getElementById('completion-modal').style.display = 'none';
		});
		
		// Fermer le modal en cliquant en dehors
		document.getElementById('completion-modal').addEventListener('click', (event) => {
			if (event.target === document.getElementById('completion-modal')) {
				document.getElementById('completion-modal').style.display = 'none';
			}
		});

        
        // Mettre à jour l'affichage du score
        updateScore();
        
        return this;
    }
    
    // Désactiver une activité après réponse
    function disableActivity() {
        const container = document.getElementById('activityContainer');
        container.querySelectorAll('input, button, .qcm-option, .term-block').forEach(el => {
            if (el.tagName === 'BUTTON') {
                el.disabled = true;
            } else {
                el.style.pointerEvents = 'none';
            }
        });
        
        container.querySelectorAll('.delete-btn').forEach(btn => {
            btn.remove();
        });
    }
    
    
    // Traiter la réponse à une question
    function processAnswer(pointId, isCorrect, feedbackMessage) {
        // Ajouter aux questions répondues
        answeredQuestions.add(pointId);
        
        // Incrémenter le score si correct
        if (isCorrect) {
            score++;
            updateScore();
            updateBadges();
        }
        
        // Afficher le feedback
        showFeedback(isCorrect, feedbackMessage);
        
        // Désactiver l'activité
        disableActivity();
        
        // Marquer comme complété dans la timeline
        markTimelineComplete(pointId);
        
        // Vérifier si toutes les questions sont répondues
        checkCompletion();
        
        // Sauvegarder l'état
        saveState();
        
        // Continuer la vidéo après un délai
        setTimeout(() => {
            continueVideo();
        }, 2000);
    }
    
    // Continuer la vidéo après une activité
    function continueVideo() {
        document.getElementById('activityContainer').classList.remove('active');
        if (player && videoStarted) {
            player.playVideo();
        }
    }
    
    // Vérifier si toutes les activités sont complétées
    function checkCompletion() {
        if (answeredQuestions.size === evaluationPoints.length) {
            document.getElementById('finishBtn').disabled = false;
            document.getElementById('finishBtn').scrollIntoView({ behavior: 'smooth' });
        }
    }
    
    
    // Désactiver une activité
    function disableActivity() {
        const container = document.getElementById('activityContainer');
        container.querySelectorAll('input, button, .qcm-option, .term-block').forEach(el => {
            if (el.tagName === 'BUTTON') {
                el.disabled = true;
            } else {
                el.style.pointerEvents = 'none';
            }
        });
        
        container.querySelectorAll('.delete-btn').forEach(btn => {
            btn.remove();
        });
    }
    
    
    // Incrémenter le score
    function incrementScore() {
        score++;
        updateScore();
        updateBadges();
    }
    
    // Mise à jour du score
    function updateScore() {
        document.getElementById('score').textContent = score;
    }
    
    // Mise à jour des badges
    function updateBadges() {
        const totalQuestions = evaluationPoints.length;
        const badges = [
            { id: 'badge1', threshold: Math.ceil(totalQuestions * 0.25) },
            { id: 'badge2', threshold: Math.ceil(totalQuestions * 0.5) },
            { id: 'badge3', threshold: Math.ceil(totalQuestions * 0.75) },
            { id: 'badge4', threshold: totalQuestions }
        ];
        
        badges.forEach(badge => {
            if (score >= badge.threshold) {
                document.getElementById(badge.id).classList.add('unlocked');
            }
        });
    }
    
// =====================================================================
##13 ⚠️⚠️⚠️ PRIORITE ABSOLUE : FIN ET MODAL 
// =====================================================================	
    
    // Fonction pour terminer l'activité
    function finishActivity() {
        if (answeredQuestions.size === 0) {
            if (!confirm('Vous n\\'avez répondu à aucune question. Êtes-vous sûr de vouloir terminer ?')) {
                return;
            }
        }
        
        activityCompleted = true;
        
        // SCORM
        if (initialized) {
            setValue("cmi.completion_status", "completed");
            setValue("cmi.success_status", (score / evaluationPoints.length >= 0.7) ? "passed" : "failed");
            setValue("cmi.exit", "normal");
            
            updateSessionTime();
            saveState();
            commitSCORM();
        }
        
        // Désactiver le bouton de fin
        document.getElementById('finishBtn').disabled = true;
        
        // Afficher le modal de complétion
        showCompletionModal();
    }
    
    // Fonction pour afficher le modal de complétion
    function showCompletionModal() {
        // Mettre à jour les informations du modal
        document.getElementById('modal-score').textContent = score;
        document.getElementById('modal-total').textContent = evaluationPoints.length;
        
        const percentage = Math.round((score / evaluationPoints.length) * 100);
        document.getElementById('modal-badge').textContent = percentage + '%';
        
        if (percentage < 70) {
            document.getElementById('modal-badge').classList.add('failed');
            document.getElementById('modal-score-text').textContent = 
                'Vous n\\'avez pas atteint le score minimum de 70%.';
        } else {
            document.getElementById('modal-badge').classList.remove('failed');
            document.getElementById('modal-score-text').textContent = 
                'Félicitations ! Vous avez réussi l\\'activité.';
        }
        
// =====================================================================
##14 ⚠️ OBLIGATOIRE : LE RESUME DES EXERCICES DOIT ËTRE COHERENT AVEC LE SCORE 
// =====================================================================	
        
        
		// Générer le résumé des exercices
		const summaryContainer = document.getElementById('exercise-summary');
		summaryContainer.innerHTML = '';
		
		for (let i = 1; i <= totalExercises; i++) {
			const isCompleted = solved.has(i.toString());
			
			const exerciseItem = document.createElement('div');
			exerciseItem.className = 'exercise-item';
			exerciseItem.innerHTML = 
				"<span>Exercice " + i + "</span>" + 
				"<span class=\"exercise-status " + (isCompleted ? "status-completed" : "status-incomplete") + "\">" +
				(isCompleted ? "✓ Réussi" : "✗ Non réussi") +
				"</span>";
			
			summaryContainer.appendChild(exerciseItem);
		}
        
        // Afficher le modal
        document.getElementById('completion-modal').style.display = 'flex';
        
        // Ajouter l'événement de fermeture au bouton
        document.getElementById('close-modal-btn').addEventListener('click', closeModal);
        
        // Fermer le modal en cliquant en dehors
        document.getElementById('completion-modal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeModal();
            }
        });
    }
    
// =====================================================================
##15 ⚠️ IMPORTANT  : LE MODAL SE FERME SOIT EN CLIQUANT EN DEHORS OU EN CLIQUANT SUR FERMER
// =====================================================================	
    
    // Fermer le modal
    function closeModal() {
        document.getElementById('completion-modal').style.display = 'none';
    }
    
    // Désactiver tous les inputs et boutons sauf le bouton de fermeture
    document.querySelectorAll('input, button, .qcm-option').forEach(el => {
        if (el !== document.getElementById('close-modal-btn') && el.tagName === 'BUTTON') {
            el.disabled = true;
        } else {
            el.style.pointerEvents = 'none';
        }
    });
    
    // Réactiver le bouton de fermeture du modal
    const closeBtn = document.getElementById('close-modal-btn');
    if (closeBtn) {
        closeBtn.disabled = false;
        closeBtn.style.pointerEvents = 'auto';
    }
});

// =====================================================================
##16 ⚠️ IMPORTANT : BOUTON FERMER DU MODAL  
// =====================================================================

<#1 !-- CODE HTML BOUTON FERMER DU MODAL   --> 
<div class="modal-footer">
    <button id="close-modal-btn" class="close-modal-btn">Fermer</button>
</div>
<#1 !-- FIN CODE HTML BOUTON FERMER DU MODAL   --> 

<#2 !-- CODE CSS BOUTON FERMER DU MODAL --> 

.modal-footer {
    margin-top: 20px;
    text-align: center;
}

.close-modal-btn {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: 30px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    min-width: 150px;
}

.close-modal-btn:hover {
    background: var(--primary-dark);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(157, 78, 221, 0.3);
}

.close-modal-btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(123, 44, 191, 0.4);
}

<#2 !-- FIN CODE CSS BOUTON FERMER DU MODAL --> 

<#3 !-- CODE JAVASCRIPT BOUTON FERMER DU MODAL --> 
/*
// Code désactivé pour éviter l'interférence
document.addEventListener('DOMContentLoaded', function() {
    const closeModalBtn = document.getElementById('close-modal-btn');
    const completionModal = document.getElementById('completion-modal');
    
    closeModalBtn.addEventListener('click', function() {
        completionModal.style.display = 'none';
    });
    
    // Fermer le modal en cliquant en dehors
    completionModal.addEventListener('click', function(event) {
        if (event.target === this) {
            completionModal.style.display = 'none';
        }
    });
});
<#3 !-- FIN CODE JAVASCRIPT BOUTON FERMER DU MODAL --> 


`;


            // Ajouter les instructions techniques
            if (appState.includeCode === 'full' || appState.includeCode === 'partial') {
                prompt += `\n\n## STRUCTURE DE L'APPLICATION VIDEO INTERACTIVE

// =====================================================================
##17 ⚠️⚠️⚠️ HAUTE PRIORITE : STRUCTURE DE L'APPLICATION
// =====================================================================	
1. Une vidéo YouTube intégrée
2. Un bouton démarrer à partir d'un temps donné et se termine à un autre temps final
3. Une timeline montrant les points d'évaluation
4. Des points d'évaluation sont des QCm, des activités d'appariement ou de calcul
5. Des activités interactives qui apparaissent quand la vidéo atteint les points définis
6. Un système de score et de feedback
7. Une intégration SCORM complète

// =====================================================================
##18 ⚠️⚠️ OBLIGATOIRE : FONCTIONNALITES DE L'APPLICATION
// =====================================================================

- La vidéo doit s'arrêter automatiquement aux points d'évaluation définis
- Les questions doivent apparaître dans une zone dédiée sous la vidéo
- L'utilisateur doit répondre correctement pour continuer
- Le score doit être calculé et transmis au LMS via SCORM
- L'état de l'application doit être sauvegardé pour permettre la reprise
- Le bilan des exercices réussis, ratés , completés où non comlétés doit être affiché à la fin d
ans un modal.
- Le modal final se ferme avec un bouton "fermer"


// =====================================================================
##19 ⚠️⚠️ OBLIGATOIRE : CODE HTML DU TEMPLATE VIDEO INTERACTIVE --> #1
// =====================================================================		

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activité Vidéo Interactive</title>
</head>
<body>
    <div class="score-board">
        Score: <span class="score" id="score">0</span> / <span id="total">6</span>
    </div>
    
    <div class="container">
        <h1>Activité Vidéo Interactive</h1>
        <div class="typescorm">SCORM App</div>
        
        <div class="badges-container">
            <!-- Les badges seront insérés ici -->
        </div>
        
        <div class="player-container" id="playerContainer">
            <div class="video-container">
                <div id="player"></div>
                
				<!-- Overlay pour le début de vidéo -->
				<div class="video-overlay" id="videoStartOverlay">
					La vidéo commence à [DEBUT_VIDEO] secondes
				</div>
                </div>
                <!-- Overlay pour la fin de vidéo -->
                <div class="video-overlay" id="videoEndOverlay" style="display: none;">
                    Vidéo terminée
                </div>
            </div>
        </div>
           
            
            <div class="activity-container" id="activityContainer">
                <!-- Le contenu des activités sera généré dynamiquement ici -->
            </div>
        </div>
        
        <div class="timeline" id="timeline">
            <div class="timeline-progress" id="timelineProgress"></div>
            <!-- Points d'évaluation générés dynamiquement -->
        </div>
        
        <button class="btn" id="finishBtn" disabled>Terminer l'activité</button>
    </div>
</body>
</html>

`;

                // Ajouter les détails d'implémentation
                if (appState.includeCode === 'full') {
                    prompt += `\n\n## DÉTAILS HTML D'IMPLÉMENTATION

// =====================================================================
##20 ⚠️⚠️ OBLIGATOIRE : DEBUT CODE HTML DE L APPLICATION VIDEO INTERACTIVE -->
// =====================================================================		


        /* ===== LECTEUR VIDÉO ET TIMELINE ===== */
        .player-container {
            display: flex;
            flex-direction: column;
            margin: 20px 0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            background: #fff;
        }
        
        .video-container {
            width: 100%;
            aspect-ratio: 16 / 9;
            position: relative;
        }
        
        #player {
            width: 100%;
            height: 100%;
        }
        
        .timeline {
            position: relative;
            height: 30px;
            background: #f0f0f0;
            margin: 20px 0;
            border-radius: 15px;
            overflow: hidden;
        }
        
        .timeline-progress {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, var(--primary-light), var(--primary-color));
            width: 0;
            transition: width 0.1s linear;
        }
        
        .timeline-point {
            position: absolute;
            width: 30px;
            height: 30px;
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            top: 0;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 5;
        }
        
        .timeline-point:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 0 10px rgba(106, 27, 154, 0.5);
        }
        
        .timeline-point.completed {
            background: var(--primary-color);
            color: white;
        }
        
        .timeline-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            pointer-events: none;
        }
        
        .timeline-point:hover .timeline-label {
            opacity: 1;
            bottom: -40px;
        }
        
        /* ===== OVERLAY BLANC DE FIN DE VIDEO ===== */
        .video-end-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
            z-index: 10;
        }
        
        
		/* Video overlay styles */
		.video-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: white;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 24px;
			font-weight: bold;
			color: var(--text-color);
			z-index: 10;
			text-align: center;
			padding: 20px;
		}
        
        
        /* ===== ACTIVITÉ CONTAINER ===== */
        .activity-container {
            padding: 20px;
            background: white;
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            max-width: 800px;
            margin: 20px auto;
        }
        
        .activity-container.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
            animation: fadeIn 0.5s ease;
        }
        
        .activity-header {
            font-size: 1.5em;
            color: var(--primary-color);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary-color);
        }
        
        .activity-question {
            font-size: 1.2em;
            margin-bottom: 20px;
            background: #f9f5ff;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--primary-color);
        }
        
        /* ===== STYLES QCM ===== */
        .qcm-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }
        
        .qcm-option {
            padding: 15px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .qcm-option:hover {
            background: #efefef;
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.05);
        }
        
        .qcm-option.selected {
            background: var(--secondary-color);
            border-color: var(--primary-color);
        }
        
        .qcm-option.correct {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .qcm-option.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        /* ===== STYLES CALCUL ===== */
        .formula-display {
            background: #f9f5ff;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.3em;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
            color: var(--primary-color);
            border: 1px solid var(--secondary-color);
        }
        
        .calc-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .calc-value {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 8px;
        }
        
        .calc-value-label {
            font-weight: bold;
            margin-right: 10px;
            color: var(--primary-color);
        }
        
        .calc-value-num {
            font-family: monospace;
            font-size: 1.1em;
        }
        
        .calc-input {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #ddd;
            border-radius: 10px;
            margin: 10px 0;
            transition: all 0.3s;
        }
        
        .calc-input:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 3px var(--secondary-color);
        }
        
        /* ===== STYLES APPARIEMENT ===== */
        .matching-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .matching-column {
            flex: 1;
            min-width: 250px;
        }
        
        .matching-column h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
        }
        
        .term-block {
            background: var(--secondary-color);
            color: var(--primary-dark);
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            cursor: grab;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s;
        }
        
        .term-block:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.1);
        }
        
        .term-block.dragging {
            opacity: 0.5;
        }
        
        .definition-zone {
            background: #f5f5f5;
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            min-height: 60px;
            position: relative;
            transition: all 0.3s;
        }
        
        .definition-zone.drag-over {
            background: #ebebeb;
            border-color: var(--primary-color);
        }
        
        .definition-text {
            padding: 10px;
            line-height: 1.4;
        }
        
        .paired-term {
            background: var(--secondary-color);
            color: var(--primary-dark);
            padding: 10px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        
        .delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            background: #f8d7da;
            color: #dc3545;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            line-height: 1;
            transition: all 0.3s;
        }
        
        .delete-btn:hover {
            background: #dc3545;
            color: white;
            transform: scale(1.1);
        }
        
        .definition-zone.correct {
            background: #d4edda;
            border-color: #28a745;
        }
        
        .definition-zone.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
        }
        
        
        
        /* ===== BOUTON ET FEEDBACK ===== */
        .btn {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 20px auto 0;
            padding: 12px 24px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(106, 27, 154, 0.3);
        }
        
        .hint {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
            display: none;
        }
        
        .hint.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        .feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .feedback.show {
            opacity: 1;
        }
        
        .feedback.correct {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* ===== CSS POUR LE BOUTON FIN ET MODAL ===== */
        .finish-btn {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 30px auto 0;
            padding: 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .finish-btn:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .finish-btn:disabled {
            background: #8fcb99;
            opacity: 0.7;
            cursor: default;
            transform: none;
        }
        
		/* Styles pour le modal de fin d'activité */
		.modal-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7);
			display: none;
			justify-content: center;
			align-items: center;
			z-index: 2000;
			animation: fadeIn 0.3s ease-out;
		}
		
		.modal-content {
			background: white;
			border-radius: 20px;
			padding: 30px;
			max-width: 500px;
			width: 90%;
			box-shadow: 0 5px 30px rgba(0, 0, 0, 0.3);
			text-align: center;
			position: relative;
			animation: slideIn 0.4s ease-out;
		}
		
		.modal-header {
			margin-bottom: 20px;
		}
		
		.modal-header h2 {
			color: var(--primary-color);
			font-size: 2em;
			margin-bottom: 10px;
		}
		
		.modal-body {
			margin-bottom: 25px;
		}
		
		.score-result {
			font-size: 3em;
			font-weight: bold;
			color: var(--primary-color);
			margin: 15px 0;
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		.score-text {
			font-size: 1.2em;
			margin-bottom: 15px;
		}
		
		.exercise-summary {
			background: #f8f9fa;
			border-radius: 10px;
			padding: 15px;
			margin-bottom: 20px;
			text-align: left;
		}
		
		.exercise-item {
			display: flex;
			justify-content: space-between;
			padding: 8px 0;
			border-bottom: 1px solid #eee;
		}
		
		.exercise-item:last-child {
			border-bottom: none;
		}
		
		.exercise-status {
			font-weight: bold;
		}
		
		.status-completed {
			color: #28a745;
		}
		
		.status-incomplete {
			color: #dc3545;
		}
		
		.modal-footer {
			margin-top: 20px;
		}
		
		.close-modal-btn {
			background: var(--primary-color);
			color: white;
			border: none;
			padding: 12px 30px;
			border-radius: 30px;
			font-size: 1.1em;
			font-weight: bold;
			cursor: pointer;
			transition: all 0.3s;
		}
		
		.close-modal-btn:hover {
			background: var(--primary-dark);
			transform: translateY(-2px);
			box-shadow: 0 5px 15px rgba(67, 97, 238, 0.3);
		}
		
		.modal-badge {
			position: absolute;
			top: -15px;
			right: -15px;
			width: 70px;
			height: 70px;
			display: flex;
			align-items: center;
			justify-content: center;
			background: var(--success-color);
			color: white;
			font-weight: bold;
			font-size: 1.2em;
			border-radius: 50%;
			box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
			border: 4px solid white;
		}
		
		.modal-badge.failed {
			background: var(--danger-color);
		}
		
		@keyframes fadeIn {
			from { opacity: 0; }
			to { opacity: 1; }
		}
		
		@keyframes slideIn {
			from { transform: translateY(-50px); opacity: 0; }
			to { transform: translateY(0); opacity: 1; }
		}
		
		/* Styles responsifs pour le modal */
		@media (max-width: 768px) {
			.modal-content {
				width: 95%;
				padding: 20px;
			}
			
			.modal-header h2 {
				font-size: 1.5em;
			}
			
			.score-result {
				font-size: 2.5em;
			}
			
			.modal-badge {
				width: 60px;
				height: 60px;
				font-size: 1em;
			}
		}
        
        /* ===== ANIMATIONS ET MÉDIAS QUERIES ===== */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px 15px;
            }
            
            .score-board {
                position: static;
                margin-bottom: 20px;
                text-align: center;
            }
            
            .matching-container {
                flex-direction: column;
            }
            
            .modal-content {
                width: 95%;
                padding: 20px;
            }
            
            .modal-header h2 {
                font-size: 1.5em;
            }
            
            .score-result {
                font-size: 2.5em;
            }
            
            .modal-badge {
                width: 60px;
                height: 60px;
                font-size: 1em;
            }
            
            .timeline-point {
                width: 25px;
                height: 25px;
                font-size: 0.8em;
            }
        }
    </style>
    

// =====================================================================
##21 ⚠️ PRIORITE HAUTE : RAPPELS ET SYNTHESE DU PROMPT : TOUS LES ELEMENTS SUIVANTS SONT A PRENDRE EN COMPTE
// =====================================================================

##0 THEME DE COULEUR DE L APPLICATION
##0 NOTES IMPORTANTES SUR LA GAMIFICATION
##1 BOUTON DEMARRER LA VIDEO
##2 BOUTON PLEIN ECRAN
##3 FORMAT POUR EN TETE
##4 BOUTON TERMINER L ACTIVITE
##5 MODAL ET RESUME DE L ACTIVITE : EXERCICES / REUSSITE / OU ECHEC / OU NON COMPLETES
##6 ⚠️COMPATIBILITÉ SCORM
##7 JAVASCRIPT SPECIFIQUE AU TEMPLATE VIDEO INTERACTIVE
##8 CONFIGURATION POINTS EVALUATION
##9 ACTIVITÉ QCM 
##10 ACTIVITÉ CALCUL
##11 ACTIVITÉ APPARIEMENT 
##12 SI L ACTIVITE EST TERMINEE LES POINTS D EVALUATION SONT DESACTIVES
##13 FIN ET MODAL
##14 LE RESUME DES EXERCICES COHERENT AVEC LE SCORE 
##15 FERMETURE DU MODAL : SOIT EN CLIQUANT EN DEHORS OU EN CLIQUANT SUR FERMER
##16 BOUTON FERMER DU MODAL
##17 STRUCTURE DE L'APPLICATION 
##18 FONCTIONNALITES DE L'APPLICATION 
##19 CODE HTML DU TEMPLATE VIDEO INTERACTIVE
##20 DEBUT CODE HTML DE L APPLICATION VIDEO INTERACTIVE

`;
                }
            }

            // Ajouter les instructions supplémentaires
            if (appState.additionalInstructions) {
                prompt += `\n\n## INSTRUCTIONS SUPPLÉMENTAIRES
${appState.additionalInstructions}`;
            }

            return prompt;
        }

        // Fonction pour copier le prompt
        function copyPrompt() {
            if (!appState.generatedPrompt) {
                showNotification("Veuillez d'abord générer un prompt!");
                return;
            }
            
            navigator.clipboard.writeText(appState.generatedPrompt)
                .then(() => {
                    showNotification("Prompt copié dans le presse-papiers!");
                })
                .catch(err => {
                    console.error("Erreur lors de la copie:", err);
                    showNotification("Erreur lors de la copie du prompt!");
                });
        }

        // Fonction pour télécharger le prompt
        function downloadPrompt() {
            if (!appState.generatedPrompt) {
                showNotification("Veuillez d'abord générer un prompt!");
                return;
            }
            
            // Créer un élément a temporaire
            const element = document.createElement('a');
            const file = new Blob([appState.generatedPrompt], {type: 'text/plain'});
            element.href = URL.createObjectURL(file);
            element.download = "video-interactive-prompt.txt";
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
            
            showNotification("Prompt téléchargé!");
        }

        // Fonction pour afficher/masquer les sections techniques
        function toggleTechnicalSections() {
            appState.showCode = !appState.showCode;
            
            const toggleBtn = document.getElementById('toggle-technical-btn');
            toggleBtn.innerHTML = appState.showCode
                ? '<i class="fas fa-code"></i> Masquer code'
                : '<i class="fas fa-code"></i> Afficher code';
            
            // Régénérer le prompt
            generatePrompt();
        }

        // Fonction pour ouvrir le site d'une IA
        function openAI(url) {
            if (!appState.generatedPrompt) {
                showNotification("Veuillez d'abord générer un prompt!");
                return;
            }
            
            // Copier le prompt dans le presse-papiers
            navigator.clipboard.writeText(appState.generatedPrompt)
                .then(() => {
                    // Ouvrir l'URL dans un nouvel onglet
                    window.open(url, '_blank');
                    showNotification("Prompt copié dans le presse-papiers! Ouverture de " + url);
                })
                .catch(err => {
                    console.error("Erreur lors de la copie:", err);
                    showNotification("Erreur lors de la copie du prompt!");
                });
        }

        // Initialisation de l'application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialiser les onglets
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabNumber = this.getAttribute('data-tab');
                    changeTab(parseInt(tabNumber));
                });
            });
            
            // Initialiser les boutons de navigation
            document.getElementById('next-tab-1').addEventListener('click', () => changeTab(2));
            document.getElementById('next-tab-2').addEventListener('click', () => changeTab(3));
            document.getElementById('next-tab-3').addEventListener('click', () => changeTab(4));
            document.getElementById('prev-tab-2').addEventListener('click', () => changeTab(1));
            document.getElementById('prev-tab-3').addEventListener('click', () => changeTab(2));
            document.getElementById('prev-tab-4').addEventListener('click', () => changeTab(3));
            
            // Initialiser les boutons des points d'évaluation
            document.getElementById('add-evaluation-point').addEventListener('click', addEvaluationPoint);
            document.getElementById('reorder-evaluation-points').addEventListener('click', reorderEvaluationPoints);
            document.getElementById('distribute-evaluation-points').addEventListener('click', distributeEvaluationPoints);
            
            // Initialiser le bouton de synchronisation de point
            document.getElementById('sync-point-button').addEventListener('click', createPointAtCurrentTime);
            
            // Initialiser le bouton de génération de prompt
            document.getElementById('generate-prompt-btn').addEventListener('click', generatePrompt);
            
            // Initialiser le bouton de copie de prompt
            document.getElementById('copy-prompt-btn').addEventListener('click', copyPrompt);
            
            // Initialiser le bouton de téléchargement de prompt
            document.getElementById('download-prompt-btn').addEventListener('click', downloadPrompt);
            
            // Initialiser le bouton de toggle des sections techniques
            document.getElementById('toggle-technical-btn').addEventListener('click', toggleTechnicalSections);
            
            // Initialiser les boutons d'ouverture d'IA
            document.getElementById('open-claude-btn').addEventListener('click', () => openAI('https://claude.ai'));
            document.getElementById('open-chatgpt-btn').addEventListener('click', () => openAI('https://chat.openai.com'));
            
            // Initialiser le champ de sujet personnalisé
            document.getElementById('subject-select').addEventListener('change', function() {
                const customContainer = document.getElementById('custom-subject-container');
                if (this.value === 'custom') {
                    customContainer.style.display = 'block';
                } else {
                    customContainer.style.display = 'none';
                }
            });
            
            // Initialiser le switch des badges
            document.getElementById('enable-badges').addEventListener('change', function() {
                const badgesSettings = document.getElementById('badges-settings');
                if (this.checked) {
                    badgesSettings.style.display = 'block';
                } else {
                    badgesSettings.style.display = 'none';
                }
                
                appState.enableBadges = this.checked;
            });
            
            // Initialiser le switch de couleur personnalisée
            document.getElementById('use-custom-color').addEventListener('change', function() {
                appState.useCustomColor = this.checked;
            });
            
            // Initialiser les écouteurs pour les mises à jour d'état
            document.getElementById('app-title').addEventListener('input', function() {
                appState.title = this.value;
            });
            
            document.getElementById('app-description').addEventListener('input', function() {
                appState.description = this.value;
            });
            
            document.getElementById('app-author').addEventListener('input', function() {
                appState.author = this.value;
            });
            
            document.getElementById('subject-select').addEventListener('change', function() {
                appState.subject = this.value;
            });
            
            document.getElementById('custom-subject').addEventListener('input', function() {
                appState.customSubject = this.value;
            });
            
            document.getElementById('difficulty-select').addEventListener('change', function() {
                appState.difficulty = this.value;
            });
            
            document.getElementById('audience-select').addEventListener('change', function() {
                appState.audience = this.value;
            });
            
            // Initialiser l'état par défaut
            appState.contentTheme = "";
            appState.contentInstructions = "";
            
            document.getElementById('badge-threshold').addEventListener('change', function() {
                appState.badgeThreshold = this.value;
            });
            
            document.getElementById('badge-count').addEventListener('change', function() {
                appState.badgeCount = parseInt(this.value);
            });
            
            document.getElementById('color-theme').addEventListener('change', function() {
                appState.colorTheme = this.value;
            });
            
            document.getElementById('custom-primary-color').addEventListener('input', function() {
                appState.customPrimaryColor = this.value;
            });
            
            document.getElementById('ui-style').addEventListener('change', function() {
                appState.uiStyle = this.value;
            });
            
            document.getElementById('font-family').addEventListener('change', function() {
                appState.fontFamily = this.value;
            });
            
            document.getElementById('custom-css').addEventListener('input', function() {
                appState.customCSS = this.value;
            });
            
            document.getElementById('prompt-format').addEventListener('change', function() {
                appState.promptFormat = this.value;
            });
            
            document.getElementById('ai-target').addEventListener('change', function() {
                appState.aiTarget = this.value;
            });
            
            document.getElementById('include-code').addEventListener('change', function() {
                appState.includeCode = this.value;
            });
            
            document.getElementById('additional-instructions').addEventListener('input', function() {
                appState.additionalInstructions = this.value;
            });
            
            // Initialiser les écouteurs pour les paramètres de vidéo
            document.getElementById('video-url').addEventListener('change', function() {
                updateVideoPreview();
            });
            
            document.getElementById('video-start').addEventListener('change', function() {
                appState.templateSettings.video.startTime = parseInt(this.value) || 0;
                renderTimelinePoints();
            });
            
            document.getElementById('video-end').addEventListener('change', function() {
                appState.templateSettings.video.endTime = parseInt(this.value) || 240;
                renderTimelinePoints();
            });
            
            // Initialiser les cases à cocher pour les fonctionnalités
            document.querySelectorAll('[id^="feature-"]').forEach(checkbox => {
                const feature = checkbox.id.replace('feature-', '');
                checkbox.addEventListener('change', function() {
                    appState.features[feature] = this.checked;
                });
                
                // Initialiser avec les valeurs de l'état
                checkbox.checked = appState.features[feature] || false;
            });
            
            // Initialiser les points d'évaluation par défaut
            if (!appState.templateSettings.video.evaluationPoints.length) {
                appState.templateSettings.video.evaluationPoints = initializeEvaluationPoints();
            }
            
            // Charger l'API YouTube si on est sur l'onglet de contenu
            if (document.getElementById('tab-content-3').classList.contains('active')) {
                loadYouTubeAPI();
            }
            
            // Initialiser l'affichage des points d'évaluation
            renderEvaluationPoints();
            renderTimelinePoints();
        });
    </script>
</body>
</html>
